
ArduinoUnoFreertos_6_1.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000022  00800100  00000fb4  00001048  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000fb4  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000649  00800122  00800122  0000106a  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000106a  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  0000109c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000208  00000000  00000000  000010dc  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00002bd9  00000000  00000000  000012e4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000d93  00000000  00000000  00003ebd  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000017c3  00000000  00000000  00004c50  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000620  00000000  00000000  00006414  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000fd0  00000000  00000000  00006a34  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000235b  00000000  00000000  00007a04  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000230  00000000  00000000  00009d5f  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
   4:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
   8:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
   c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  24:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  2c:	0c 94 9d 02 	jmp	0x53a	; 0x53a <__vector_11>
  30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  40:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  48:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  4c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  54:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
  68:	11 24       	eor	r1, r1
  6a:	1f be       	out	0x3f, r1	; 63
  6c:	cf ef       	ldi	r28, 0xFF	; 255
  6e:	d8 e0       	ldi	r29, 0x08	; 8
  70:	de bf       	out	0x3e, r29	; 62
  72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
  74:	11 e0       	ldi	r17, 0x01	; 1
  76:	a0 e0       	ldi	r26, 0x00	; 0
  78:	b1 e0       	ldi	r27, 0x01	; 1
  7a:	e4 eb       	ldi	r30, 0xB4	; 180
  7c:	ff e0       	ldi	r31, 0x0F	; 15
  7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
  80:	05 90       	lpm	r0, Z+
  82:	0d 92       	st	X+, r0
  84:	a2 32       	cpi	r26, 0x22	; 34
  86:	b1 07       	cpc	r27, r17
  88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
  8a:	27 e0       	ldi	r18, 0x07	; 7
  8c:	a2 e2       	ldi	r26, 0x22	; 34
  8e:	b1 e0       	ldi	r27, 0x01	; 1
  90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
  92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
  94:	ab 36       	cpi	r26, 0x6B	; 107
  96:	b2 07       	cpc	r27, r18
  98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
  9a:	0e 94 91 00 	call	0x122	; 0x122 <main>
  9e:	0c 94 d8 07 	jmp	0xfb0	; 0xfb0 <_exit>

000000a2 <__bad_interrupt>:
  a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <vPedestrianLightTask>:

// ===================================================
// Pedestrian Light Task
// ===================================================
void vPedestrianLightTask(void *pvParameters)
{
  a6:	cf 93       	push	r28
  a8:	df 93       	push	r29
  aa:	00 d0       	rcall	.+0      	; 0xac <vPedestrianLightTask+0x6>
  ac:	cd b7       	in	r28, 0x3d	; 61
  ae:	de b7       	in	r29, 0x3e	; 62
	TickType_t xLastWakeTime = xTaskGetTickCount();
  b0:	0e 94 54 05 	call	0xaa8	; 0xaa8 <xTaskGetTickCount>
  b4:	9a 83       	std	Y+2, r25	; 0x02
  b6:	89 83       	std	Y+1, r24	; 0x01

	while (1)
	{
		// Simple blinking effect while crossing (optional)
		PORTB ^= (1 << PB2);  // Toggle pedestrian green LED
  b8:	14 e0       	ldi	r17, 0x04	; 4
  ba:	85 b1       	in	r24, 0x05	; 5
  bc:	81 27       	eor	r24, r17
  be:	85 b9       	out	0x05, r24	; 5
		vTaskDelayUntil(&xLastWakeTime, pdMS_TO_TICKS(500)); // Blink every 0.5s
  c0:	69 e2       	ldi	r22, 0x29	; 41
  c2:	70 e0       	ldi	r23, 0x00	; 0
  c4:	ce 01       	movw	r24, r28
  c6:	01 96       	adiw	r24, 0x01	; 1
  c8:	0e 94 9d 06 	call	0xd3a	; 0xd3a <vTaskDelayUntil>
  cc:	f6 cf       	rjmp	.-20     	; 0xba <vPedestrianLightTask+0x14>

000000ce <vVehicleLightTask>:

// ===================================================
// Vehicle Light Task
// ===================================================
void vVehicleLightTask(void *pvParameters)
{
  ce:	cf 93       	push	r28
  d0:	df 93       	push	r29
  d2:	00 d0       	rcall	.+0      	; 0xd4 <vVehicleLightTask+0x6>
  d4:	cd b7       	in	r28, 0x3d	; 61
  d6:	de b7       	in	r29, 0x3e	; 62
	TickType_t xLastWakeTime = xTaskGetTickCount();
  d8:	0e 94 54 05 	call	0xaa8	; 0xaa8 <xTaskGetTickCount>
  dc:	9a 83       	std	Y+2, r25	; 0x02
  de:	89 83       	std	Y+1, r24	; 0x01

	while (1)
	{
		// ===== VEHICLE GREEN PHASE =====
		PORTB |= (1 << PB0);   // Vehicle GREEN ON
  e0:	28 9a       	sbi	0x05, 0	; 5
		PORTB &= ~(1 << PB1);  // Vehicle RED OFF
  e2:	29 98       	cbi	0x05, 1	; 5

		PORTB |= (1 << PB3);   // Pedestrian RED ON
  e4:	2b 9a       	sbi	0x05, 3	; 5
		PORTB &= ~(1 << PB2);  // Pedestrian GREEN OFF
  e6:	2a 98       	cbi	0x05, 2	; 5

		vTaskSuspend(xPedestrianHandle);  // Stop pedestrian task
  e8:	80 91 69 07 	lds	r24, 0x0769	; 0x800769 <xPedestrianHandle>
  ec:	90 91 6a 07 	lds	r25, 0x076A	; 0x80076a <xPedestrianHandle+0x1>
  f0:	0e 94 89 07 	call	0xf12	; 0xf12 <vTaskSuspend>
		vTaskDelayUntil(&xLastWakeTime, pdMS_TO_TICKS(3000)); // 3 seconds
  f4:	62 e3       	ldi	r22, 0x32	; 50
  f6:	70 e0       	ldi	r23, 0x00	; 0
  f8:	ce 01       	movw	r24, r28
  fa:	01 96       	adiw	r24, 0x01	; 1
  fc:	0e 94 9d 06 	call	0xd3a	; 0xd3a <vTaskDelayUntil>

		// ===== VEHICLE RED PHASE =====
		PORTB &= ~(1 << PB0);  // Vehicle GREEN OFF
 100:	28 98       	cbi	0x05, 0	; 5
		PORTB |= (1 << PB1);   // Vehicle RED ON
 102:	29 9a       	sbi	0x05, 1	; 5

		PORTB &= ~(1 << PB3);  // Pedestrian RED OFF
 104:	2b 98       	cbi	0x05, 3	; 5
		PORTB |= (1 << PB2);   // Pedestrian GREEN ON
 106:	2a 9a       	sbi	0x05, 2	; 5

		vTaskResume(xPedestrianHandle); // Let pedestrians cross
 108:	80 91 69 07 	lds	r24, 0x0769	; 0x800769 <xPedestrianHandle>
 10c:	90 91 6a 07 	lds	r25, 0x076A	; 0x80076a <xPedestrianHandle+0x1>
 110:	0e 94 d4 04 	call	0x9a8	; 0x9a8 <vTaskResume>
		vTaskDelayUntil(&xLastWakeTime, pdMS_TO_TICKS(2000)); // 2 seconds
 114:	61 e2       	ldi	r22, 0x21	; 33
 116:	70 e0       	ldi	r23, 0x00	; 0
 118:	ce 01       	movw	r24, r28
 11a:	01 96       	adiw	r24, 0x01	; 1
 11c:	0e 94 9d 06 	call	0xd3a	; 0xd3a <vTaskDelayUntil>
 120:	df cf       	rjmp	.-66     	; 0xe0 <vVehicleLightTask+0x12>

00000122 <main>:
void vVehicleLightTask(void *pvParameters);
void vPedestrianLightTask(void *pvParameters);

int main(void)
{
	DDRB = 0xFF; // All PORTB pins as outputs for LEDs
 122:	8f ef       	ldi	r24, 0xFF	; 255
 124:	84 b9       	out	0x04, r24	; 4

	// Create tasks
	xTaskCreate(vVehicleLightTask, "VehicleLights", 256, NULL, 2, NULL);
 126:	a1 2c       	mov	r10, r1
 128:	b1 2c       	mov	r11, r1
 12a:	c1 2c       	mov	r12, r1
 12c:	d1 2c       	mov	r13, r1
 12e:	e1 2c       	mov	r14, r1
 130:	f1 2c       	mov	r15, r1
 132:	02 e0       	ldi	r16, 0x02	; 2
 134:	20 e0       	ldi	r18, 0x00	; 0
 136:	30 e0       	ldi	r19, 0x00	; 0
 138:	40 e0       	ldi	r20, 0x00	; 0
 13a:	51 e0       	ldi	r21, 0x01	; 1
 13c:	64 e0       	ldi	r22, 0x04	; 4
 13e:	71 e0       	ldi	r23, 0x01	; 1
 140:	87 e6       	ldi	r24, 0x67	; 103
 142:	90 e0       	ldi	r25, 0x00	; 0
 144:	0e 94 c3 03 	call	0x786	; 0x786 <xTaskGenericCreate>
	xTaskCreate(vPedestrianLightTask, "PedLights", 256, NULL, 1, &xPedestrianHandle);
 148:	0f 2e       	mov	r0, r31
 14a:	f9 e6       	ldi	r31, 0x69	; 105
 14c:	ef 2e       	mov	r14, r31
 14e:	f7 e0       	ldi	r31, 0x07	; 7
 150:	ff 2e       	mov	r15, r31
 152:	f0 2d       	mov	r31, r0
 154:	01 e0       	ldi	r16, 0x01	; 1
 156:	20 e0       	ldi	r18, 0x00	; 0
 158:	30 e0       	ldi	r19, 0x00	; 0
 15a:	40 e0       	ldi	r20, 0x00	; 0
 15c:	51 e0       	ldi	r21, 0x01	; 1
 15e:	62 e1       	ldi	r22, 0x12	; 18
 160:	71 e0       	ldi	r23, 0x01	; 1
 162:	83 e5       	ldi	r24, 0x53	; 83
 164:	90 e0       	ldi	r25, 0x00	; 0
 166:	0e 94 c3 03 	call	0x786	; 0x786 <xTaskGenericCreate>

	// Start scheduler
	vTaskStartScheduler();
 16a:	0e 94 23 05 	call	0xa46	; 0xa46 <vTaskStartScheduler>
 16e:	ff cf       	rjmp	.-2      	; 0x16e <main+0x4c>

00000170 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
 170:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 172:	03 96       	adiw	r24, 0x03	; 3
 174:	92 83       	std	Z+2, r25	; 0x02
 176:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 178:	2f ef       	ldi	r18, 0xFF	; 255
 17a:	3f ef       	ldi	r19, 0xFF	; 255
 17c:	34 83       	std	Z+4, r19	; 0x04
 17e:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 180:	96 83       	std	Z+6, r25	; 0x06
 182:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 184:	90 87       	std	Z+8, r25	; 0x08
 186:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 188:	10 82       	st	Z, r1
 18a:	08 95       	ret

0000018c <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 18c:	fc 01       	movw	r30, r24
 18e:	11 86       	std	Z+9, r1	; 0x09
 190:	10 86       	std	Z+8, r1	; 0x08
 192:	08 95       	ret

00000194 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 194:	cf 93       	push	r28
 196:	df 93       	push	r29
 198:	9c 01       	movw	r18, r24
 19a:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
 19c:	dc 01       	movw	r26, r24
 19e:	11 96       	adiw	r26, 0x01	; 1
 1a0:	cd 91       	ld	r28, X+
 1a2:	dc 91       	ld	r29, X
 1a4:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
 1a6:	d3 83       	std	Z+3, r29	; 0x03
 1a8:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 1aa:	8c 81       	ldd	r24, Y+4	; 0x04
 1ac:	9d 81       	ldd	r25, Y+5	; 0x05
 1ae:	95 83       	std	Z+5, r25	; 0x05
 1b0:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
 1b2:	8c 81       	ldd	r24, Y+4	; 0x04
 1b4:	9d 81       	ldd	r25, Y+5	; 0x05
 1b6:	dc 01       	movw	r26, r24
 1b8:	13 96       	adiw	r26, 0x03	; 3
 1ba:	7c 93       	st	X, r23
 1bc:	6e 93       	st	-X, r22
 1be:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
 1c0:	7d 83       	std	Y+5, r23	; 0x05
 1c2:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 1c4:	31 87       	std	Z+9, r19	; 0x09
 1c6:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
 1c8:	f9 01       	movw	r30, r18
 1ca:	80 81       	ld	r24, Z
 1cc:	8f 5f       	subi	r24, 0xFF	; 255
 1ce:	80 83       	st	Z, r24
}
 1d0:	df 91       	pop	r29
 1d2:	cf 91       	pop	r28
 1d4:	08 95       	ret

000001d6 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 1d6:	cf 93       	push	r28
 1d8:	df 93       	push	r29
 1da:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 1dc:	48 81       	ld	r20, Y
 1de:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 1e0:	4f 3f       	cpi	r20, 0xFF	; 255
 1e2:	2f ef       	ldi	r18, 0xFF	; 255
 1e4:	52 07       	cpc	r21, r18
 1e6:	21 f4       	brne	.+8      	; 0x1f0 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 1e8:	fc 01       	movw	r30, r24
 1ea:	a7 81       	ldd	r26, Z+7	; 0x07
 1ec:	b0 85       	ldd	r27, Z+8	; 0x08
 1ee:	0d c0       	rjmp	.+26     	; 0x20a <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 1f0:	dc 01       	movw	r26, r24
 1f2:	13 96       	adiw	r26, 0x03	; 3
 1f4:	01 c0       	rjmp	.+2      	; 0x1f8 <vListInsert+0x22>
 1f6:	df 01       	movw	r26, r30
 1f8:	12 96       	adiw	r26, 0x02	; 2
 1fa:	ed 91       	ld	r30, X+
 1fc:	fc 91       	ld	r31, X
 1fe:	13 97       	sbiw	r26, 0x03	; 3
 200:	20 81       	ld	r18, Z
 202:	31 81       	ldd	r19, Z+1	; 0x01
 204:	42 17       	cp	r20, r18
 206:	53 07       	cpc	r21, r19
 208:	b0 f7       	brcc	.-20     	; 0x1f6 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 20a:	12 96       	adiw	r26, 0x02	; 2
 20c:	ed 91       	ld	r30, X+
 20e:	fc 91       	ld	r31, X
 210:	13 97       	sbiw	r26, 0x03	; 3
 212:	fb 83       	std	Y+3, r31	; 0x03
 214:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 216:	d5 83       	std	Z+5, r29	; 0x05
 218:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
 21a:	bd 83       	std	Y+5, r27	; 0x05
 21c:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
 21e:	13 96       	adiw	r26, 0x03	; 3
 220:	dc 93       	st	X, r29
 222:	ce 93       	st	-X, r28
 224:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 226:	99 87       	std	Y+9, r25	; 0x09
 228:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
 22a:	fc 01       	movw	r30, r24
 22c:	20 81       	ld	r18, Z
 22e:	2f 5f       	subi	r18, 0xFF	; 255
 230:	20 83       	st	Z, r18
}
 232:	df 91       	pop	r29
 234:	cf 91       	pop	r28
 236:	08 95       	ret

00000238 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
 238:	cf 93       	push	r28
 23a:	df 93       	push	r29
 23c:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
 23e:	a0 85       	ldd	r26, Z+8	; 0x08
 240:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 242:	c2 81       	ldd	r28, Z+2	; 0x02
 244:	d3 81       	ldd	r29, Z+3	; 0x03
 246:	84 81       	ldd	r24, Z+4	; 0x04
 248:	95 81       	ldd	r25, Z+5	; 0x05
 24a:	9d 83       	std	Y+5, r25	; 0x05
 24c:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 24e:	c4 81       	ldd	r28, Z+4	; 0x04
 250:	d5 81       	ldd	r29, Z+5	; 0x05
 252:	82 81       	ldd	r24, Z+2	; 0x02
 254:	93 81       	ldd	r25, Z+3	; 0x03
 256:	9b 83       	std	Y+3, r25	; 0x03
 258:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 25a:	11 96       	adiw	r26, 0x01	; 1
 25c:	8d 91       	ld	r24, X+
 25e:	9c 91       	ld	r25, X
 260:	12 97       	sbiw	r26, 0x02	; 2
 262:	e8 17       	cp	r30, r24
 264:	f9 07       	cpc	r31, r25
 266:	31 f4       	brne	.+12     	; 0x274 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 268:	84 81       	ldd	r24, Z+4	; 0x04
 26a:	95 81       	ldd	r25, Z+5	; 0x05
 26c:	12 96       	adiw	r26, 0x02	; 2
 26e:	9c 93       	st	X, r25
 270:	8e 93       	st	-X, r24
 272:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
 274:	11 86       	std	Z+9, r1	; 0x09
 276:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
 278:	8c 91       	ld	r24, X
 27a:	81 50       	subi	r24, 0x01	; 1
 27c:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
 27e:	df 91       	pop	r29
 280:	cf 91       	pop	r28
 282:	08 95       	ret

00000284 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
 284:	31 e1       	ldi	r19, 0x11	; 17
 286:	fc 01       	movw	r30, r24
 288:	30 83       	st	Z, r19
 28a:	31 97       	sbiw	r30, 0x01	; 1
 28c:	22 e2       	ldi	r18, 0x22	; 34
 28e:	20 83       	st	Z, r18
 290:	31 97       	sbiw	r30, 0x01	; 1
 292:	a3 e3       	ldi	r26, 0x33	; 51
 294:	a0 83       	st	Z, r26
 296:	31 97       	sbiw	r30, 0x01	; 1
 298:	60 83       	st	Z, r22
 29a:	31 97       	sbiw	r30, 0x01	; 1
 29c:	70 83       	st	Z, r23
 29e:	31 97       	sbiw	r30, 0x01	; 1
 2a0:	10 82       	st	Z, r1
 2a2:	31 97       	sbiw	r30, 0x01	; 1
 2a4:	60 e8       	ldi	r22, 0x80	; 128
 2a6:	60 83       	st	Z, r22
 2a8:	31 97       	sbiw	r30, 0x01	; 1
 2aa:	10 82       	st	Z, r1
 2ac:	31 97       	sbiw	r30, 0x01	; 1
 2ae:	62 e0       	ldi	r22, 0x02	; 2
 2b0:	60 83       	st	Z, r22
 2b2:	31 97       	sbiw	r30, 0x01	; 1
 2b4:	63 e0       	ldi	r22, 0x03	; 3
 2b6:	60 83       	st	Z, r22
 2b8:	31 97       	sbiw	r30, 0x01	; 1
 2ba:	64 e0       	ldi	r22, 0x04	; 4
 2bc:	60 83       	st	Z, r22
 2be:	31 97       	sbiw	r30, 0x01	; 1
 2c0:	65 e0       	ldi	r22, 0x05	; 5
 2c2:	60 83       	st	Z, r22
 2c4:	31 97       	sbiw	r30, 0x01	; 1
 2c6:	66 e0       	ldi	r22, 0x06	; 6
 2c8:	60 83       	st	Z, r22
 2ca:	31 97       	sbiw	r30, 0x01	; 1
 2cc:	67 e0       	ldi	r22, 0x07	; 7
 2ce:	60 83       	st	Z, r22
 2d0:	31 97       	sbiw	r30, 0x01	; 1
 2d2:	68 e0       	ldi	r22, 0x08	; 8
 2d4:	60 83       	st	Z, r22
 2d6:	31 97       	sbiw	r30, 0x01	; 1
 2d8:	69 e0       	ldi	r22, 0x09	; 9
 2da:	60 83       	st	Z, r22
 2dc:	31 97       	sbiw	r30, 0x01	; 1
 2de:	60 e1       	ldi	r22, 0x10	; 16
 2e0:	60 83       	st	Z, r22
 2e2:	31 97       	sbiw	r30, 0x01	; 1
 2e4:	30 83       	st	Z, r19
 2e6:	31 97       	sbiw	r30, 0x01	; 1
 2e8:	32 e1       	ldi	r19, 0x12	; 18
 2ea:	30 83       	st	Z, r19
 2ec:	31 97       	sbiw	r30, 0x01	; 1
 2ee:	33 e1       	ldi	r19, 0x13	; 19
 2f0:	30 83       	st	Z, r19
 2f2:	31 97       	sbiw	r30, 0x01	; 1
 2f4:	34 e1       	ldi	r19, 0x14	; 20
 2f6:	30 83       	st	Z, r19
 2f8:	31 97       	sbiw	r30, 0x01	; 1
 2fa:	35 e1       	ldi	r19, 0x15	; 21
 2fc:	30 83       	st	Z, r19
 2fe:	31 97       	sbiw	r30, 0x01	; 1
 300:	36 e1       	ldi	r19, 0x16	; 22
 302:	30 83       	st	Z, r19
 304:	31 97       	sbiw	r30, 0x01	; 1
 306:	37 e1       	ldi	r19, 0x17	; 23
 308:	30 83       	st	Z, r19
 30a:	31 97       	sbiw	r30, 0x01	; 1
 30c:	38 e1       	ldi	r19, 0x18	; 24
 30e:	30 83       	st	Z, r19
 310:	31 97       	sbiw	r30, 0x01	; 1
 312:	39 e1       	ldi	r19, 0x19	; 25
 314:	30 83       	st	Z, r19
 316:	31 97       	sbiw	r30, 0x01	; 1
 318:	30 e2       	ldi	r19, 0x20	; 32
 31a:	30 83       	st	Z, r19
 31c:	31 97       	sbiw	r30, 0x01	; 1
 31e:	31 e2       	ldi	r19, 0x21	; 33
 320:	30 83       	st	Z, r19
 322:	31 97       	sbiw	r30, 0x01	; 1
 324:	20 83       	st	Z, r18
 326:	31 97       	sbiw	r30, 0x01	; 1
 328:	23 e2       	ldi	r18, 0x23	; 35
 32a:	20 83       	st	Z, r18
 32c:	31 97       	sbiw	r30, 0x01	; 1
 32e:	40 83       	st	Z, r20
 330:	31 97       	sbiw	r30, 0x01	; 1
 332:	50 83       	st	Z, r21
 334:	31 97       	sbiw	r30, 0x01	; 1
 336:	26 e2       	ldi	r18, 0x26	; 38
 338:	20 83       	st	Z, r18
 33a:	31 97       	sbiw	r30, 0x01	; 1
 33c:	27 e2       	ldi	r18, 0x27	; 39
 33e:	20 83       	st	Z, r18
 340:	31 97       	sbiw	r30, 0x01	; 1
 342:	28 e2       	ldi	r18, 0x28	; 40
 344:	20 83       	st	Z, r18
 346:	31 97       	sbiw	r30, 0x01	; 1
 348:	29 e2       	ldi	r18, 0x29	; 41
 34a:	20 83       	st	Z, r18
 34c:	31 97       	sbiw	r30, 0x01	; 1
 34e:	20 e3       	ldi	r18, 0x30	; 48
 350:	20 83       	st	Z, r18
 352:	31 97       	sbiw	r30, 0x01	; 1
 354:	21 e3       	ldi	r18, 0x31	; 49
 356:	20 83       	st	Z, r18
 358:	86 97       	sbiw	r24, 0x26	; 38
 35a:	08 95       	ret

0000035c <xPortStartScheduler>:
 35c:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x7f8089>
 360:	8c e7       	ldi	r24, 0x7C	; 124
 362:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7f8088>
 366:	8b e0       	ldi	r24, 0x0B	; 11
 368:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7f8081>
 36c:	ef e6       	ldi	r30, 0x6F	; 111
 36e:	f0 e0       	ldi	r31, 0x00	; 0
 370:	80 81       	ld	r24, Z
 372:	82 60       	ori	r24, 0x02	; 2
 374:	80 83       	st	Z, r24
 376:	a0 91 67 07 	lds	r26, 0x0767	; 0x800767 <pxCurrentTCB>
 37a:	b0 91 68 07 	lds	r27, 0x0768	; 0x800768 <pxCurrentTCB+0x1>
 37e:	cd 91       	ld	r28, X+
 380:	cd bf       	out	0x3d, r28	; 61
 382:	dd 91       	ld	r29, X+
 384:	de bf       	out	0x3e, r29	; 62
 386:	ff 91       	pop	r31
 388:	ef 91       	pop	r30
 38a:	df 91       	pop	r29
 38c:	cf 91       	pop	r28
 38e:	bf 91       	pop	r27
 390:	af 91       	pop	r26
 392:	9f 91       	pop	r25
 394:	8f 91       	pop	r24
 396:	7f 91       	pop	r23
 398:	6f 91       	pop	r22
 39a:	5f 91       	pop	r21
 39c:	4f 91       	pop	r20
 39e:	3f 91       	pop	r19
 3a0:	2f 91       	pop	r18
 3a2:	1f 91       	pop	r17
 3a4:	0f 91       	pop	r16
 3a6:	ff 90       	pop	r15
 3a8:	ef 90       	pop	r14
 3aa:	df 90       	pop	r13
 3ac:	cf 90       	pop	r12
 3ae:	bf 90       	pop	r11
 3b0:	af 90       	pop	r10
 3b2:	9f 90       	pop	r9
 3b4:	8f 90       	pop	r8
 3b6:	7f 90       	pop	r7
 3b8:	6f 90       	pop	r6
 3ba:	5f 90       	pop	r5
 3bc:	4f 90       	pop	r4
 3be:	3f 90       	pop	r3
 3c0:	2f 90       	pop	r2
 3c2:	1f 90       	pop	r1
 3c4:	0f 90       	pop	r0
 3c6:	0f be       	out	0x3f, r0	; 63
 3c8:	0f 90       	pop	r0
 3ca:	08 95       	ret
 3cc:	81 e0       	ldi	r24, 0x01	; 1
 3ce:	08 95       	ret

000003d0 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
 3d0:	0f 92       	push	r0
 3d2:	0f b6       	in	r0, 0x3f	; 63
 3d4:	f8 94       	cli
 3d6:	0f 92       	push	r0
 3d8:	1f 92       	push	r1
 3da:	11 24       	eor	r1, r1
 3dc:	2f 92       	push	r2
 3de:	3f 92       	push	r3
 3e0:	4f 92       	push	r4
 3e2:	5f 92       	push	r5
 3e4:	6f 92       	push	r6
 3e6:	7f 92       	push	r7
 3e8:	8f 92       	push	r8
 3ea:	9f 92       	push	r9
 3ec:	af 92       	push	r10
 3ee:	bf 92       	push	r11
 3f0:	cf 92       	push	r12
 3f2:	df 92       	push	r13
 3f4:	ef 92       	push	r14
 3f6:	ff 92       	push	r15
 3f8:	0f 93       	push	r16
 3fa:	1f 93       	push	r17
 3fc:	2f 93       	push	r18
 3fe:	3f 93       	push	r19
 400:	4f 93       	push	r20
 402:	5f 93       	push	r21
 404:	6f 93       	push	r22
 406:	7f 93       	push	r23
 408:	8f 93       	push	r24
 40a:	9f 93       	push	r25
 40c:	af 93       	push	r26
 40e:	bf 93       	push	r27
 410:	cf 93       	push	r28
 412:	df 93       	push	r29
 414:	ef 93       	push	r30
 416:	ff 93       	push	r31
 418:	a0 91 67 07 	lds	r26, 0x0767	; 0x800767 <pxCurrentTCB>
 41c:	b0 91 68 07 	lds	r27, 0x0768	; 0x800768 <pxCurrentTCB+0x1>
 420:	0d b6       	in	r0, 0x3d	; 61
 422:	0d 92       	st	X+, r0
 424:	0e b6       	in	r0, 0x3e	; 62
 426:	0d 92       	st	X+, r0
	vTaskSwitchContext();
 428:	0e 94 1c 07 	call	0xe38	; 0xe38 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
 42c:	a0 91 67 07 	lds	r26, 0x0767	; 0x800767 <pxCurrentTCB>
 430:	b0 91 68 07 	lds	r27, 0x0768	; 0x800768 <pxCurrentTCB+0x1>
 434:	cd 91       	ld	r28, X+
 436:	cd bf       	out	0x3d, r28	; 61
 438:	dd 91       	ld	r29, X+
 43a:	de bf       	out	0x3e, r29	; 62
 43c:	ff 91       	pop	r31
 43e:	ef 91       	pop	r30
 440:	df 91       	pop	r29
 442:	cf 91       	pop	r28
 444:	bf 91       	pop	r27
 446:	af 91       	pop	r26
 448:	9f 91       	pop	r25
 44a:	8f 91       	pop	r24
 44c:	7f 91       	pop	r23
 44e:	6f 91       	pop	r22
 450:	5f 91       	pop	r21
 452:	4f 91       	pop	r20
 454:	3f 91       	pop	r19
 456:	2f 91       	pop	r18
 458:	1f 91       	pop	r17
 45a:	0f 91       	pop	r16
 45c:	ff 90       	pop	r15
 45e:	ef 90       	pop	r14
 460:	df 90       	pop	r13
 462:	cf 90       	pop	r12
 464:	bf 90       	pop	r11
 466:	af 90       	pop	r10
 468:	9f 90       	pop	r9
 46a:	8f 90       	pop	r8
 46c:	7f 90       	pop	r7
 46e:	6f 90       	pop	r6
 470:	5f 90       	pop	r5
 472:	4f 90       	pop	r4
 474:	3f 90       	pop	r3
 476:	2f 90       	pop	r2
 478:	1f 90       	pop	r1
 47a:	0f 90       	pop	r0
 47c:	0f be       	out	0x3f, r0	; 63
 47e:	0f 90       	pop	r0

	asm volatile ( "ret" );
 480:	08 95       	ret

00000482 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
 482:	0f 92       	push	r0
 484:	0f b6       	in	r0, 0x3f	; 63
 486:	f8 94       	cli
 488:	0f 92       	push	r0
 48a:	1f 92       	push	r1
 48c:	11 24       	eor	r1, r1
 48e:	2f 92       	push	r2
 490:	3f 92       	push	r3
 492:	4f 92       	push	r4
 494:	5f 92       	push	r5
 496:	6f 92       	push	r6
 498:	7f 92       	push	r7
 49a:	8f 92       	push	r8
 49c:	9f 92       	push	r9
 49e:	af 92       	push	r10
 4a0:	bf 92       	push	r11
 4a2:	cf 92       	push	r12
 4a4:	df 92       	push	r13
 4a6:	ef 92       	push	r14
 4a8:	ff 92       	push	r15
 4aa:	0f 93       	push	r16
 4ac:	1f 93       	push	r17
 4ae:	2f 93       	push	r18
 4b0:	3f 93       	push	r19
 4b2:	4f 93       	push	r20
 4b4:	5f 93       	push	r21
 4b6:	6f 93       	push	r22
 4b8:	7f 93       	push	r23
 4ba:	8f 93       	push	r24
 4bc:	9f 93       	push	r25
 4be:	af 93       	push	r26
 4c0:	bf 93       	push	r27
 4c2:	cf 93       	push	r28
 4c4:	df 93       	push	r29
 4c6:	ef 93       	push	r30
 4c8:	ff 93       	push	r31
 4ca:	a0 91 67 07 	lds	r26, 0x0767	; 0x800767 <pxCurrentTCB>
 4ce:	b0 91 68 07 	lds	r27, 0x0768	; 0x800768 <pxCurrentTCB+0x1>
 4d2:	0d b6       	in	r0, 0x3d	; 61
 4d4:	0d 92       	st	X+, r0
 4d6:	0e b6       	in	r0, 0x3e	; 62
 4d8:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
 4da:	0e 94 5e 05 	call	0xabc	; 0xabc <xTaskIncrementTick>
 4de:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
 4e0:	0e 94 1c 07 	call	0xe38	; 0xe38 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
 4e4:	a0 91 67 07 	lds	r26, 0x0767	; 0x800767 <pxCurrentTCB>
 4e8:	b0 91 68 07 	lds	r27, 0x0768	; 0x800768 <pxCurrentTCB+0x1>
 4ec:	cd 91       	ld	r28, X+
 4ee:	cd bf       	out	0x3d, r28	; 61
 4f0:	dd 91       	ld	r29, X+
 4f2:	de bf       	out	0x3e, r29	; 62
 4f4:	ff 91       	pop	r31
 4f6:	ef 91       	pop	r30
 4f8:	df 91       	pop	r29
 4fa:	cf 91       	pop	r28
 4fc:	bf 91       	pop	r27
 4fe:	af 91       	pop	r26
 500:	9f 91       	pop	r25
 502:	8f 91       	pop	r24
 504:	7f 91       	pop	r23
 506:	6f 91       	pop	r22
 508:	5f 91       	pop	r21
 50a:	4f 91       	pop	r20
 50c:	3f 91       	pop	r19
 50e:	2f 91       	pop	r18
 510:	1f 91       	pop	r17
 512:	0f 91       	pop	r16
 514:	ff 90       	pop	r15
 516:	ef 90       	pop	r14
 518:	df 90       	pop	r13
 51a:	cf 90       	pop	r12
 51c:	bf 90       	pop	r11
 51e:	af 90       	pop	r10
 520:	9f 90       	pop	r9
 522:	8f 90       	pop	r8
 524:	7f 90       	pop	r7
 526:	6f 90       	pop	r6
 528:	5f 90       	pop	r5
 52a:	4f 90       	pop	r4
 52c:	3f 90       	pop	r3
 52e:	2f 90       	pop	r2
 530:	1f 90       	pop	r1
 532:	0f 90       	pop	r0
 534:	0f be       	out	0x3f, r0	; 63
 536:	0f 90       	pop	r0

	asm volatile ( "ret" );
 538:	08 95       	ret

0000053a <__vector_11>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect(void) __attribute__ ((signal, naked));
	void TIMER1_COMPA_vect(void)
	{
		vPortYieldFromTick();
 53a:	0e 94 41 02 	call	0x482	; 0x482 <vPortYieldFromTick>
		asm volatile ( "reti" );
 53e:	18 95       	reti

00000540 <pvPortMalloc>:
	pxIterator->pxNextFreeBlock = pxBlockToInsert;									\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
 540:	0f 93       	push	r16
 542:	1f 93       	push	r17
 544:	cf 93       	push	r28
 546:	df 93       	push	r29
 548:	ec 01       	movw	r28, r24
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
 54a:	0e 94 4e 05 	call	0xa9c	; 0xa9c <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
 54e:	80 91 22 01 	lds	r24, 0x0122	; 0x800122 <__data_end>
 552:	81 11       	cpse	r24, r1
 554:	1d c0       	rjmp	.+58     	; 0x590 <pvPortMalloc+0x50>
	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 556:	e7 e2       	ldi	r30, 0x27	; 39
 558:	f1 e0       	ldi	r31, 0x01	; 1
 55a:	8c e2       	ldi	r24, 0x2C	; 44
 55c:	91 e0       	ldi	r25, 0x01	; 1
 55e:	91 83       	std	Z+1, r25	; 0x01
 560:	80 83       	st	Z, r24
	xStart.xBlockSize = ( size_t ) 0;
 562:	13 82       	std	Z+3, r1	; 0x03
 564:	12 82       	std	Z+2, r1	; 0x02

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
 566:	e3 e2       	ldi	r30, 0x23	; 35
 568:	f1 e0       	ldi	r31, 0x01	; 1
 56a:	8b ed       	ldi	r24, 0xDB	; 219
 56c:	95 e0       	ldi	r25, 0x05	; 5
 56e:	93 83       	std	Z+3, r25	; 0x03
 570:	82 83       	std	Z+2, r24	; 0x02
	xEnd.pxNextFreeBlock = NULL;
 572:	11 82       	std	Z+1, r1	; 0x01
 574:	10 82       	st	Z, r1

	/* To start with there is a single free block that is sized to take up the
	entire heap space. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;
 576:	ab e2       	ldi	r26, 0x2B	; 43
 578:	b1 e0       	ldi	r27, 0x01	; 1
 57a:	14 96       	adiw	r26, 0x04	; 4
 57c:	9c 93       	st	X, r25
 57e:	8e 93       	st	-X, r24
 580:	13 97       	sbiw	r26, 0x03	; 3
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
 582:	12 96       	adiw	r26, 0x02	; 2
 584:	fc 93       	st	X, r31
 586:	ee 93       	st	-X, r30
 588:	11 97       	sbiw	r26, 0x01	; 1
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
		{
			prvHeapInit();
			xHeapHasBeenInitialised = pdTRUE;
 58a:	81 e0       	ldi	r24, 0x01	; 1
 58c:	80 93 22 01 	sts	0x0122, r24	; 0x800122 <__data_end>
		}

		/* The wanted size is increased so it can contain a BlockLink_t
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
 590:	20 97       	sbiw	r28, 0x00	; 0
 592:	09 f4       	brne	.+2      	; 0x596 <pvPortMalloc+0x56>
 594:	5f c0       	rjmp	.+190    	; 0x654 <pvPortMalloc+0x114>
		{
			xWantedSize += heapSTRUCT_SIZE;
 596:	9e 01       	movw	r18, r28
 598:	2c 5f       	subi	r18, 0xFC	; 252
 59a:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
 59c:	23 96       	adiw	r28, 0x03	; 3
 59e:	ca 3d       	cpi	r28, 0xDA	; 218
 5a0:	d5 40       	sbci	r29, 0x05	; 5
 5a2:	08 f0       	brcs	.+2      	; 0x5a6 <pvPortMalloc+0x66>
 5a4:	5a c0       	rjmp	.+180    	; 0x65a <pvPortMalloc+0x11a>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
 5a6:	e0 91 27 01 	lds	r30, 0x0127	; 0x800127 <xStart>
 5aa:	f0 91 28 01 	lds	r31, 0x0128	; 0x800128 <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
 5ae:	a7 e2       	ldi	r26, 0x27	; 39
 5b0:	b1 e0       	ldi	r27, 0x01	; 1
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 5b2:	02 c0       	rjmp	.+4      	; 0x5b8 <pvPortMalloc+0x78>
 5b4:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
 5b6:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 5b8:	82 81       	ldd	r24, Z+2	; 0x02
 5ba:	93 81       	ldd	r25, Z+3	; 0x03
 5bc:	82 17       	cp	r24, r18
 5be:	93 07       	cpc	r25, r19
 5c0:	20 f4       	brcc	.+8      	; 0x5ca <pvPortMalloc+0x8a>
 5c2:	80 81       	ld	r24, Z
 5c4:	91 81       	ldd	r25, Z+1	; 0x01
 5c6:	00 97       	sbiw	r24, 0x00	; 0
 5c8:	a9 f7       	brne	.-22     	; 0x5b4 <pvPortMalloc+0x74>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
 5ca:	c1 e0       	ldi	r28, 0x01	; 1
 5cc:	e3 32       	cpi	r30, 0x23	; 35
 5ce:	fc 07       	cpc	r31, r28
 5d0:	09 f4       	brne	.+2      	; 0x5d4 <pvPortMalloc+0x94>
 5d2:	46 c0       	rjmp	.+140    	; 0x660 <pvPortMalloc+0x120>
			{
				/* Return the memory space - jumping over the BlockLink_t structure
				at its start. */
				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
 5d4:	cd 91       	ld	r28, X+
 5d6:	dc 91       	ld	r29, X
 5d8:	11 97       	sbiw	r26, 0x01	; 1
 5da:	8e 01       	movw	r16, r28
 5dc:	0c 5f       	subi	r16, 0xFC	; 252
 5de:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken out of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 5e0:	80 81       	ld	r24, Z
 5e2:	91 81       	ldd	r25, Z+1	; 0x01
 5e4:	8d 93       	st	X+, r24
 5e6:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 5e8:	82 81       	ldd	r24, Z+2	; 0x02
 5ea:	93 81       	ldd	r25, Z+3	; 0x03
 5ec:	82 1b       	sub	r24, r18
 5ee:	93 0b       	sbc	r25, r19
 5f0:	89 30       	cpi	r24, 0x09	; 9
 5f2:	91 05       	cpc	r25, r1
 5f4:	10 f1       	brcs	.+68     	; 0x63a <pvPortMalloc+0xfa>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
 5f6:	bf 01       	movw	r22, r30
 5f8:	62 0f       	add	r22, r18
 5fa:	73 1f       	adc	r23, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 5fc:	db 01       	movw	r26, r22
 5fe:	13 96       	adiw	r26, 0x03	; 3
 600:	9c 93       	st	X, r25
 602:	8e 93       	st	-X, r24
 604:	12 97       	sbiw	r26, 0x02	; 2
					pxBlock->xBlockSize = xWantedSize;
 606:	33 83       	std	Z+3, r19	; 0x03
 608:	22 83       	std	Z+2, r18	; 0x02

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
 60a:	12 96       	adiw	r26, 0x02	; 2
 60c:	4d 91       	ld	r20, X+
 60e:	5c 91       	ld	r21, X
 610:	13 97       	sbiw	r26, 0x03	; 3
 612:	87 e2       	ldi	r24, 0x27	; 39
 614:	91 e0       	ldi	r25, 0x01	; 1
 616:	01 c0       	rjmp	.+2      	; 0x61a <pvPortMalloc+0xda>
 618:	cd 01       	movw	r24, r26
 61a:	ec 01       	movw	r28, r24
 61c:	a8 81       	ld	r26, Y
 61e:	b9 81       	ldd	r27, Y+1	; 0x01
 620:	12 96       	adiw	r26, 0x02	; 2
 622:	2d 91       	ld	r18, X+
 624:	3c 91       	ld	r19, X
 626:	13 97       	sbiw	r26, 0x03	; 3
 628:	24 17       	cp	r18, r20
 62a:	35 07       	cpc	r19, r21
 62c:	a8 f3       	brcs	.-22     	; 0x618 <pvPortMalloc+0xd8>
 62e:	eb 01       	movw	r28, r22
 630:	b9 83       	std	Y+1, r27	; 0x01
 632:	a8 83       	st	Y, r26
 634:	dc 01       	movw	r26, r24
 636:	6d 93       	st	X+, r22
 638:	7c 93       	st	X, r23
				}

				xFreeBytesRemaining -= pxBlock->xBlockSize;
 63a:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
 63e:	90 91 01 01 	lds	r25, 0x0101	; 0x800101 <__DATA_REGION_ORIGIN__+0x1>
 642:	22 81       	ldd	r18, Z+2	; 0x02
 644:	33 81       	ldd	r19, Z+3	; 0x03
 646:	82 1b       	sub	r24, r18
 648:	93 0b       	sbc	r25, r19
 64a:	90 93 01 01 	sts	0x0101, r25	; 0x800101 <__DATA_REGION_ORIGIN__+0x1>
 64e:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__DATA_REGION_ORIGIN__>
 652:	08 c0       	rjmp	.+16     	; 0x664 <pvPortMalloc+0x124>

void *pvPortMalloc( size_t xWantedSize )
{
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
 654:	00 e0       	ldi	r16, 0x00	; 0
 656:	10 e0       	ldi	r17, 0x00	; 0
 658:	05 c0       	rjmp	.+10     	; 0x664 <pvPortMalloc+0x124>
 65a:	00 e0       	ldi	r16, 0x00	; 0
 65c:	10 e0       	ldi	r17, 0x00	; 0
 65e:	02 c0       	rjmp	.+4      	; 0x664 <pvPortMalloc+0x124>
 660:	00 e0       	ldi	r16, 0x00	; 0
 662:	10 e0       	ldi	r17, 0x00	; 0
			}
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
 664:	0e 94 1b 06 	call	0xc36	; 0xc36 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
 668:	c8 01       	movw	r24, r16
 66a:	df 91       	pop	r29
 66c:	cf 91       	pop	r28
 66e:	1f 91       	pop	r17
 670:	0f 91       	pop	r16
 672:	08 95       	ret

00000674 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
 674:	0f 93       	push	r16
 676:	1f 93       	push	r17
 678:	cf 93       	push	r28
 67a:	df 93       	push	r29
uint8_t *puc = ( uint8_t * ) pv;
BlockLink_t *pxLink;

	if( pv != NULL )
 67c:	00 97       	sbiw	r24, 0x00	; 0
 67e:	41 f1       	breq	.+80     	; 0x6d0 <vPortFree+0x5c>
 680:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
 682:	8c 01       	movw	r16, r24
 684:	04 50       	subi	r16, 0x04	; 4
 686:	11 09       	sbc	r17, r1

		/* This unexpected casting is to keep some compilers from issuing
		byte alignment warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
 688:	0e 94 4e 05 	call	0xa9c	; 0xa9c <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 68c:	f8 01       	movw	r30, r16
 68e:	42 81       	ldd	r20, Z+2	; 0x02
 690:	53 81       	ldd	r21, Z+3	; 0x03
 692:	a7 e2       	ldi	r26, 0x27	; 39
 694:	b1 e0       	ldi	r27, 0x01	; 1
 696:	01 c0       	rjmp	.+2      	; 0x69a <vPortFree+0x26>
 698:	df 01       	movw	r26, r30
 69a:	ed 91       	ld	r30, X+
 69c:	fc 91       	ld	r31, X
 69e:	11 97       	sbiw	r26, 0x01	; 1
 6a0:	22 81       	ldd	r18, Z+2	; 0x02
 6a2:	33 81       	ldd	r19, Z+3	; 0x03
 6a4:	24 17       	cp	r18, r20
 6a6:	35 07       	cpc	r19, r21
 6a8:	b8 f3       	brcs	.-18     	; 0x698 <vPortFree+0x24>
 6aa:	24 97       	sbiw	r28, 0x04	; 4
 6ac:	f9 83       	std	Y+1, r31	; 0x01
 6ae:	e8 83       	st	Y, r30
 6b0:	0d 93       	st	X+, r16
 6b2:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
 6b4:	20 91 00 01 	lds	r18, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
 6b8:	30 91 01 01 	lds	r19, 0x0101	; 0x800101 <__DATA_REGION_ORIGIN__+0x1>
 6bc:	8a 81       	ldd	r24, Y+2	; 0x02
 6be:	9b 81       	ldd	r25, Y+3	; 0x03
 6c0:	82 0f       	add	r24, r18
 6c2:	93 1f       	adc	r25, r19
 6c4:	90 93 01 01 	sts	0x0101, r25	; 0x800101 <__DATA_REGION_ORIGIN__+0x1>
 6c8:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__DATA_REGION_ORIGIN__>
			traceFREE( pv, pxLink->xBlockSize );
		}
		( void ) xTaskResumeAll();
 6cc:	0e 94 1b 06 	call	0xc36	; 0xc36 <xTaskResumeAll>
	}
}
 6d0:	df 91       	pop	r29
 6d2:	cf 91       	pop	r28
 6d4:	1f 91       	pop	r17
 6d6:	0f 91       	pop	r16
 6d8:	08 95       	ret

000006da <prvResetNextTaskUnblockTime>:
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 6da:	e0 91 2f 07 	lds	r30, 0x072F	; 0x80072f <pxDelayedTaskList>
 6de:	f0 91 30 07 	lds	r31, 0x0730	; 0x800730 <pxDelayedTaskList+0x1>
 6e2:	80 81       	ld	r24, Z
 6e4:	81 11       	cpse	r24, r1
 6e6:	07 c0       	rjmp	.+14     	; 0x6f6 <prvResetNextTaskUnblockTime+0x1c>
 6e8:	8f ef       	ldi	r24, 0xFF	; 255
 6ea:	9f ef       	ldi	r25, 0xFF	; 255
 6ec:	90 93 03 01 	sts	0x0103, r25	; 0x800103 <xNextTaskUnblockTime+0x1>
 6f0:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <xNextTaskUnblockTime>
 6f4:	08 95       	ret
 6f6:	e0 91 2f 07 	lds	r30, 0x072F	; 0x80072f <pxDelayedTaskList>
 6fa:	f0 91 30 07 	lds	r31, 0x0730	; 0x800730 <pxDelayedTaskList+0x1>
 6fe:	05 80       	ldd	r0, Z+5	; 0x05
 700:	f6 81       	ldd	r31, Z+6	; 0x06
 702:	e0 2d       	mov	r30, r0
 704:	06 80       	ldd	r0, Z+6	; 0x06
 706:	f7 81       	ldd	r31, Z+7	; 0x07
 708:	e0 2d       	mov	r30, r0
 70a:	82 81       	ldd	r24, Z+2	; 0x02
 70c:	93 81       	ldd	r25, Z+3	; 0x03
 70e:	90 93 03 01 	sts	0x0103, r25	; 0x800103 <xNextTaskUnblockTime+0x1>
 712:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <xNextTaskUnblockTime>
 716:	08 95       	ret

00000718 <prvAddCurrentTaskToDelayedList>:
 718:	cf 93       	push	r28
 71a:	df 93       	push	r29
 71c:	ec 01       	movw	r28, r24
 71e:	e0 91 67 07 	lds	r30, 0x0767	; 0x800767 <pxCurrentTCB>
 722:	f0 91 68 07 	lds	r31, 0x0768	; 0x800768 <pxCurrentTCB+0x1>
 726:	93 83       	std	Z+3, r25	; 0x03
 728:	82 83       	std	Z+2, r24	; 0x02
 72a:	80 91 0e 07 	lds	r24, 0x070E	; 0x80070e <xTickCount>
 72e:	90 91 0f 07 	lds	r25, 0x070F	; 0x80070f <xTickCount+0x1>
 732:	c8 17       	cp	r28, r24
 734:	d9 07       	cpc	r29, r25
 736:	68 f4       	brcc	.+26     	; 0x752 <prvAddCurrentTaskToDelayedList+0x3a>
 738:	60 91 67 07 	lds	r22, 0x0767	; 0x800767 <pxCurrentTCB>
 73c:	70 91 68 07 	lds	r23, 0x0768	; 0x800768 <pxCurrentTCB+0x1>
 740:	80 91 2d 07 	lds	r24, 0x072D	; 0x80072d <pxOverflowDelayedTaskList>
 744:	90 91 2e 07 	lds	r25, 0x072E	; 0x80072e <pxOverflowDelayedTaskList+0x1>
 748:	6e 5f       	subi	r22, 0xFE	; 254
 74a:	7f 4f       	sbci	r23, 0xFF	; 255
 74c:	0e 94 eb 00 	call	0x1d6	; 0x1d6 <vListInsert>
 750:	17 c0       	rjmp	.+46     	; 0x780 <prvAddCurrentTaskToDelayedList+0x68>
 752:	60 91 67 07 	lds	r22, 0x0767	; 0x800767 <pxCurrentTCB>
 756:	70 91 68 07 	lds	r23, 0x0768	; 0x800768 <pxCurrentTCB+0x1>
 75a:	80 91 2f 07 	lds	r24, 0x072F	; 0x80072f <pxDelayedTaskList>
 75e:	90 91 30 07 	lds	r25, 0x0730	; 0x800730 <pxDelayedTaskList+0x1>
 762:	6e 5f       	subi	r22, 0xFE	; 254
 764:	7f 4f       	sbci	r23, 0xFF	; 255
 766:	0e 94 eb 00 	call	0x1d6	; 0x1d6 <vListInsert>
 76a:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <xNextTaskUnblockTime>
 76e:	90 91 03 01 	lds	r25, 0x0103	; 0x800103 <xNextTaskUnblockTime+0x1>
 772:	c8 17       	cp	r28, r24
 774:	d9 07       	cpc	r29, r25
 776:	20 f4       	brcc	.+8      	; 0x780 <prvAddCurrentTaskToDelayedList+0x68>
 778:	d0 93 03 01 	sts	0x0103, r29	; 0x800103 <xNextTaskUnblockTime+0x1>
 77c:	c0 93 02 01 	sts	0x0102, r28	; 0x800102 <xNextTaskUnblockTime>
 780:	df 91       	pop	r29
 782:	cf 91       	pop	r28
 784:	08 95       	ret

00000786 <xTaskGenericCreate>:
 786:	4f 92       	push	r4
 788:	5f 92       	push	r5
 78a:	6f 92       	push	r6
 78c:	7f 92       	push	r7
 78e:	8f 92       	push	r8
 790:	9f 92       	push	r9
 792:	af 92       	push	r10
 794:	bf 92       	push	r11
 796:	cf 92       	push	r12
 798:	df 92       	push	r13
 79a:	ef 92       	push	r14
 79c:	ff 92       	push	r15
 79e:	0f 93       	push	r16
 7a0:	1f 93       	push	r17
 7a2:	cf 93       	push	r28
 7a4:	df 93       	push	r29
 7a6:	4c 01       	movw	r8, r24
 7a8:	eb 01       	movw	r28, r22
 7aa:	5a 01       	movw	r10, r20
 7ac:	29 01       	movw	r4, r18
 7ae:	c1 14       	cp	r12, r1
 7b0:	d1 04       	cpc	r13, r1
 7b2:	39 f4       	brne	.+14     	; 0x7c2 <xTaskGenericCreate+0x3c>
 7b4:	ca 01       	movw	r24, r20
 7b6:	0e 94 a0 02 	call	0x540	; 0x540 <pvPortMalloc>
 7ba:	6c 01       	movw	r12, r24
 7bc:	89 2b       	or	r24, r25
 7be:	09 f4       	brne	.+2      	; 0x7c2 <xTaskGenericCreate+0x3c>
 7c0:	e1 c0       	rjmp	.+450    	; 0x984 <__stack+0x85>
 7c2:	86 e2       	ldi	r24, 0x26	; 38
 7c4:	90 e0       	ldi	r25, 0x00	; 0
 7c6:	0e 94 a0 02 	call	0x540	; 0x540 <pvPortMalloc>
 7ca:	3c 01       	movw	r6, r24
 7cc:	00 97       	sbiw	r24, 0x00	; 0
 7ce:	79 f0       	breq	.+30     	; 0x7ee <xTaskGenericCreate+0x68>
 7d0:	fc 01       	movw	r30, r24
 7d2:	d0 8e       	std	Z+24, r13	; 0x18
 7d4:	c7 8a       	std	Z+23, r12	; 0x17
 7d6:	f1 e0       	ldi	r31, 0x01	; 1
 7d8:	af 1a       	sub	r10, r31
 7da:	b1 08       	sbc	r11, r1
 7dc:	ca 0c       	add	r12, r10
 7de:	db 1c       	adc	r13, r11
 7e0:	88 81       	ld	r24, Y
 7e2:	f3 01       	movw	r30, r6
 7e4:	81 8f       	std	Z+25, r24	; 0x19
 7e6:	88 81       	ld	r24, Y
 7e8:	81 11       	cpse	r24, r1
 7ea:	05 c0       	rjmp	.+10     	; 0x7f6 <xTaskGenericCreate+0x70>
 7ec:	14 c0       	rjmp	.+40     	; 0x816 <__DATA_REGION_LENGTH__+0x16>
 7ee:	c6 01       	movw	r24, r12
 7f0:	0e 94 3a 03 	call	0x674	; 0x674 <vPortFree>
 7f4:	c7 c0       	rjmp	.+398    	; 0x984 <__stack+0x85>
 7f6:	d3 01       	movw	r26, r6
 7f8:	5a 96       	adiw	r26, 0x1a	; 26
 7fa:	fe 01       	movw	r30, r28
 7fc:	31 96       	adiw	r30, 0x01	; 1
 7fe:	9e 01       	movw	r18, r28
 800:	28 5f       	subi	r18, 0xF8	; 248
 802:	3f 4f       	sbci	r19, 0xFF	; 255
 804:	ef 01       	movw	r28, r30
 806:	81 91       	ld	r24, Z+
 808:	8d 93       	st	X+, r24
 80a:	88 81       	ld	r24, Y
 80c:	88 23       	and	r24, r24
 80e:	19 f0       	breq	.+6      	; 0x816 <__DATA_REGION_LENGTH__+0x16>
 810:	e2 17       	cp	r30, r18
 812:	f3 07       	cpc	r31, r19
 814:	b9 f7       	brne	.-18     	; 0x804 <__DATA_REGION_LENGTH__+0x4>
 816:	f3 01       	movw	r30, r6
 818:	10 a2       	std	Z+32, r1	; 0x20
 81a:	10 2f       	mov	r17, r16
 81c:	04 30       	cpi	r16, 0x04	; 4
 81e:	08 f0       	brcs	.+2      	; 0x822 <__DATA_REGION_LENGTH__+0x22>
 820:	13 e0       	ldi	r17, 0x03	; 3
 822:	f3 01       	movw	r30, r6
 824:	16 8b       	std	Z+22, r17	; 0x16
 826:	e3 01       	movw	r28, r6
 828:	22 96       	adiw	r28, 0x02	; 2
 82a:	ce 01       	movw	r24, r28
 82c:	0e 94 c6 00 	call	0x18c	; 0x18c <vListInitialiseItem>
 830:	c3 01       	movw	r24, r6
 832:	0c 96       	adiw	r24, 0x0c	; 12
 834:	0e 94 c6 00 	call	0x18c	; 0x18c <vListInitialiseItem>
 838:	f3 01       	movw	r30, r6
 83a:	71 86       	std	Z+9, r7	; 0x09
 83c:	60 86       	std	Z+8, r6	; 0x08
 83e:	84 e0       	ldi	r24, 0x04	; 4
 840:	90 e0       	ldi	r25, 0x00	; 0
 842:	81 1b       	sub	r24, r17
 844:	91 09       	sbc	r25, r1
 846:	95 87       	std	Z+13, r25	; 0x0d
 848:	84 87       	std	Z+12, r24	; 0x0c
 84a:	73 8a       	std	Z+19, r7	; 0x13
 84c:	62 8a       	std	Z+18, r6	; 0x12
 84e:	11 a2       	std	Z+33, r1	; 0x21
 850:	12 a2       	std	Z+34, r1	; 0x22
 852:	13 a2       	std	Z+35, r1	; 0x23
 854:	14 a2       	std	Z+36, r1	; 0x24
 856:	15 a2       	std	Z+37, r1	; 0x25
 858:	a2 01       	movw	r20, r4
 85a:	b4 01       	movw	r22, r8
 85c:	c6 01       	movw	r24, r12
 85e:	0e 94 42 01 	call	0x284	; 0x284 <pxPortInitialiseStack>
 862:	f3 01       	movw	r30, r6
 864:	91 83       	std	Z+1, r25	; 0x01
 866:	80 83       	st	Z, r24
 868:	e1 14       	cp	r14, r1
 86a:	f1 04       	cpc	r15, r1
 86c:	19 f0       	breq	.+6      	; 0x874 <__DATA_REGION_LENGTH__+0x74>
 86e:	f7 01       	movw	r30, r14
 870:	71 82       	std	Z+1, r7	; 0x01
 872:	60 82       	st	Z, r6
 874:	0f b6       	in	r0, 0x3f	; 63
 876:	f8 94       	cli
 878:	0f 92       	push	r0
 87a:	80 91 10 07 	lds	r24, 0x0710	; 0x800710 <uxCurrentNumberOfTasks>
 87e:	8f 5f       	subi	r24, 0xFF	; 255
 880:	80 93 10 07 	sts	0x0710, r24	; 0x800710 <uxCurrentNumberOfTasks>
 884:	80 91 67 07 	lds	r24, 0x0767	; 0x800767 <pxCurrentTCB>
 888:	90 91 68 07 	lds	r25, 0x0768	; 0x800768 <pxCurrentTCB+0x1>
 88c:	89 2b       	or	r24, r25
 88e:	d1 f5       	brne	.+116    	; 0x904 <__stack+0x5>
 890:	70 92 68 07 	sts	0x0768, r7	; 0x800768 <pxCurrentTCB+0x1>
 894:	60 92 67 07 	sts	0x0767, r6	; 0x800767 <pxCurrentTCB>
 898:	80 91 10 07 	lds	r24, 0x0710	; 0x800710 <uxCurrentNumberOfTasks>
 89c:	81 30       	cpi	r24, 0x01	; 1
 89e:	09 f0       	breq	.+2      	; 0x8a2 <__DATA_REGION_LENGTH__+0xa2>
 8a0:	40 c0       	rjmp	.+128    	; 0x922 <__stack+0x23>
 8a2:	83 e4       	ldi	r24, 0x43	; 67
 8a4:	97 e0       	ldi	r25, 0x07	; 7
 8a6:	0e 94 b8 00 	call	0x170	; 0x170 <vListInitialise>
 8aa:	8c e4       	ldi	r24, 0x4C	; 76
 8ac:	97 e0       	ldi	r25, 0x07	; 7
 8ae:	0e 94 b8 00 	call	0x170	; 0x170 <vListInitialise>
 8b2:	85 e5       	ldi	r24, 0x55	; 85
 8b4:	97 e0       	ldi	r25, 0x07	; 7
 8b6:	0e 94 b8 00 	call	0x170	; 0x170 <vListInitialise>
 8ba:	8e e5       	ldi	r24, 0x5E	; 94
 8bc:	97 e0       	ldi	r25, 0x07	; 7
 8be:	0e 94 b8 00 	call	0x170	; 0x170 <vListInitialise>
 8c2:	8a e3       	ldi	r24, 0x3A	; 58
 8c4:	97 e0       	ldi	r25, 0x07	; 7
 8c6:	0e 94 b8 00 	call	0x170	; 0x170 <vListInitialise>
 8ca:	81 e3       	ldi	r24, 0x31	; 49
 8cc:	97 e0       	ldi	r25, 0x07	; 7
 8ce:	0e 94 b8 00 	call	0x170	; 0x170 <vListInitialise>
 8d2:	84 e2       	ldi	r24, 0x24	; 36
 8d4:	97 e0       	ldi	r25, 0x07	; 7
 8d6:	0e 94 b8 00 	call	0x170	; 0x170 <vListInitialise>
 8da:	8b e1       	ldi	r24, 0x1B	; 27
 8dc:	97 e0       	ldi	r25, 0x07	; 7
 8de:	0e 94 b8 00 	call	0x170	; 0x170 <vListInitialise>
 8e2:	81 e1       	ldi	r24, 0x11	; 17
 8e4:	97 e0       	ldi	r25, 0x07	; 7
 8e6:	0e 94 b8 00 	call	0x170	; 0x170 <vListInitialise>
 8ea:	8a e3       	ldi	r24, 0x3A	; 58
 8ec:	97 e0       	ldi	r25, 0x07	; 7
 8ee:	90 93 30 07 	sts	0x0730, r25	; 0x800730 <pxDelayedTaskList+0x1>
 8f2:	80 93 2f 07 	sts	0x072F, r24	; 0x80072f <pxDelayedTaskList>
 8f6:	81 e3       	ldi	r24, 0x31	; 49
 8f8:	97 e0       	ldi	r25, 0x07	; 7
 8fa:	90 93 2e 07 	sts	0x072E, r25	; 0x80072e <pxOverflowDelayedTaskList+0x1>
 8fe:	80 93 2d 07 	sts	0x072D, r24	; 0x80072d <pxOverflowDelayedTaskList>
 902:	0f c0       	rjmp	.+30     	; 0x922 <__stack+0x23>
 904:	80 91 0c 07 	lds	r24, 0x070C	; 0x80070c <xSchedulerRunning>
 908:	81 11       	cpse	r24, r1
 90a:	0b c0       	rjmp	.+22     	; 0x922 <__stack+0x23>
 90c:	e0 91 67 07 	lds	r30, 0x0767	; 0x800767 <pxCurrentTCB>
 910:	f0 91 68 07 	lds	r31, 0x0768	; 0x800768 <pxCurrentTCB+0x1>
 914:	86 89       	ldd	r24, Z+22	; 0x16
 916:	08 17       	cp	r16, r24
 918:	20 f0       	brcs	.+8      	; 0x922 <__stack+0x23>
 91a:	70 92 68 07 	sts	0x0768, r7	; 0x800768 <pxCurrentTCB+0x1>
 91e:	60 92 67 07 	sts	0x0767, r6	; 0x800767 <pxCurrentTCB>
 922:	80 91 08 07 	lds	r24, 0x0708	; 0x800708 <uxTaskNumber>
 926:	8f 5f       	subi	r24, 0xFF	; 255
 928:	80 93 08 07 	sts	0x0708, r24	; 0x800708 <uxTaskNumber>
 92c:	f3 01       	movw	r30, r6
 92e:	86 89       	ldd	r24, Z+22	; 0x16
 930:	90 91 0d 07 	lds	r25, 0x070D	; 0x80070d <uxTopReadyPriority>
 934:	98 17       	cp	r25, r24
 936:	10 f4       	brcc	.+4      	; 0x93c <__stack+0x3d>
 938:	80 93 0d 07 	sts	0x070D, r24	; 0x80070d <uxTopReadyPriority>
 93c:	90 e0       	ldi	r25, 0x00	; 0
 93e:	9c 01       	movw	r18, r24
 940:	22 0f       	add	r18, r18
 942:	33 1f       	adc	r19, r19
 944:	22 0f       	add	r18, r18
 946:	33 1f       	adc	r19, r19
 948:	22 0f       	add	r18, r18
 94a:	33 1f       	adc	r19, r19
 94c:	82 0f       	add	r24, r18
 94e:	93 1f       	adc	r25, r19
 950:	be 01       	movw	r22, r28
 952:	8d 5b       	subi	r24, 0xBD	; 189
 954:	98 4f       	sbci	r25, 0xF8	; 248
 956:	0e 94 ca 00 	call	0x194	; 0x194 <vListInsertEnd>
 95a:	0f 90       	pop	r0
 95c:	0f be       	out	0x3f, r0	; 63
 95e:	80 91 0c 07 	lds	r24, 0x070C	; 0x80070c <xSchedulerRunning>
 962:	88 23       	and	r24, r24
 964:	59 f0       	breq	.+22     	; 0x97c <__stack+0x7d>
 966:	e0 91 67 07 	lds	r30, 0x0767	; 0x800767 <pxCurrentTCB>
 96a:	f0 91 68 07 	lds	r31, 0x0768	; 0x800768 <pxCurrentTCB+0x1>
 96e:	86 89       	ldd	r24, Z+22	; 0x16
 970:	80 17       	cp	r24, r16
 972:	30 f4       	brcc	.+12     	; 0x980 <__stack+0x81>
 974:	0e 94 e8 01 	call	0x3d0	; 0x3d0 <vPortYield>
 978:	81 e0       	ldi	r24, 0x01	; 1
 97a:	05 c0       	rjmp	.+10     	; 0x986 <__stack+0x87>
 97c:	81 e0       	ldi	r24, 0x01	; 1
 97e:	03 c0       	rjmp	.+6      	; 0x986 <__stack+0x87>
 980:	81 e0       	ldi	r24, 0x01	; 1
 982:	01 c0       	rjmp	.+2      	; 0x986 <__stack+0x87>
 984:	8f ef       	ldi	r24, 0xFF	; 255
 986:	df 91       	pop	r29
 988:	cf 91       	pop	r28
 98a:	1f 91       	pop	r17
 98c:	0f 91       	pop	r16
 98e:	ff 90       	pop	r15
 990:	ef 90       	pop	r14
 992:	df 90       	pop	r13
 994:	cf 90       	pop	r12
 996:	bf 90       	pop	r11
 998:	af 90       	pop	r10
 99a:	9f 90       	pop	r9
 99c:	8f 90       	pop	r8
 99e:	7f 90       	pop	r7
 9a0:	6f 90       	pop	r6
 9a2:	5f 90       	pop	r5
 9a4:	4f 90       	pop	r4
 9a6:	08 95       	ret

000009a8 <vTaskResume>:
 9a8:	0f 93       	push	r16
 9aa:	1f 93       	push	r17
 9ac:	cf 93       	push	r28
 9ae:	df 93       	push	r29
 9b0:	00 97       	sbiw	r24, 0x00	; 0
 9b2:	09 f4       	brne	.+2      	; 0x9b6 <vTaskResume+0xe>
 9b4:	43 c0       	rjmp	.+134    	; 0xa3c <vTaskResume+0x94>
 9b6:	20 91 67 07 	lds	r18, 0x0767	; 0x800767 <pxCurrentTCB>
 9ba:	30 91 68 07 	lds	r19, 0x0768	; 0x800768 <pxCurrentTCB+0x1>
 9be:	82 17       	cp	r24, r18
 9c0:	93 07       	cpc	r25, r19
 9c2:	09 f4       	brne	.+2      	; 0x9c6 <vTaskResume+0x1e>
 9c4:	3b c0       	rjmp	.+118    	; 0xa3c <vTaskResume+0x94>
 9c6:	0f b6       	in	r0, 0x3f	; 63
 9c8:	f8 94       	cli
 9ca:	0f 92       	push	r0
 9cc:	fc 01       	movw	r30, r24
 9ce:	22 85       	ldd	r18, Z+10	; 0x0a
 9d0:	33 85       	ldd	r19, Z+11	; 0x0b
 9d2:	21 51       	subi	r18, 0x11	; 17
 9d4:	37 40       	sbci	r19, 0x07	; 7
 9d6:	81 f5       	brne	.+96     	; 0xa38 <vTaskResume+0x90>
 9d8:	fc 01       	movw	r30, r24
 9da:	24 89       	ldd	r18, Z+20	; 0x14
 9dc:	35 89       	ldd	r19, Z+21	; 0x15
 9de:	f7 e0       	ldi	r31, 0x07	; 7
 9e0:	24 32       	cpi	r18, 0x24	; 36
 9e2:	3f 07       	cpc	r19, r31
 9e4:	49 f1       	breq	.+82     	; 0xa38 <vTaskResume+0x90>
 9e6:	23 2b       	or	r18, r19
 9e8:	39 f5       	brne	.+78     	; 0xa38 <vTaskResume+0x90>
 9ea:	ec 01       	movw	r28, r24
 9ec:	8c 01       	movw	r16, r24
 9ee:	0e 5f       	subi	r16, 0xFE	; 254
 9f0:	1f 4f       	sbci	r17, 0xFF	; 255
 9f2:	c8 01       	movw	r24, r16
 9f4:	0e 94 1c 01 	call	0x238	; 0x238 <uxListRemove>
 9f8:	8e 89       	ldd	r24, Y+22	; 0x16
 9fa:	90 91 0d 07 	lds	r25, 0x070D	; 0x80070d <uxTopReadyPriority>
 9fe:	98 17       	cp	r25, r24
 a00:	10 f4       	brcc	.+4      	; 0xa06 <vTaskResume+0x5e>
 a02:	80 93 0d 07 	sts	0x070D, r24	; 0x80070d <uxTopReadyPriority>
 a06:	90 e0       	ldi	r25, 0x00	; 0
 a08:	9c 01       	movw	r18, r24
 a0a:	22 0f       	add	r18, r18
 a0c:	33 1f       	adc	r19, r19
 a0e:	22 0f       	add	r18, r18
 a10:	33 1f       	adc	r19, r19
 a12:	22 0f       	add	r18, r18
 a14:	33 1f       	adc	r19, r19
 a16:	82 0f       	add	r24, r18
 a18:	93 1f       	adc	r25, r19
 a1a:	b8 01       	movw	r22, r16
 a1c:	8d 5b       	subi	r24, 0xBD	; 189
 a1e:	98 4f       	sbci	r25, 0xF8	; 248
 a20:	0e 94 ca 00 	call	0x194	; 0x194 <vListInsertEnd>
 a24:	e0 91 67 07 	lds	r30, 0x0767	; 0x800767 <pxCurrentTCB>
 a28:	f0 91 68 07 	lds	r31, 0x0768	; 0x800768 <pxCurrentTCB+0x1>
 a2c:	9e 89       	ldd	r25, Y+22	; 0x16
 a2e:	86 89       	ldd	r24, Z+22	; 0x16
 a30:	98 17       	cp	r25, r24
 a32:	10 f0       	brcs	.+4      	; 0xa38 <vTaskResume+0x90>
 a34:	0e 94 e8 01 	call	0x3d0	; 0x3d0 <vPortYield>
 a38:	0f 90       	pop	r0
 a3a:	0f be       	out	0x3f, r0	; 63
 a3c:	df 91       	pop	r29
 a3e:	cf 91       	pop	r28
 a40:	1f 91       	pop	r17
 a42:	0f 91       	pop	r16
 a44:	08 95       	ret

00000a46 <vTaskStartScheduler>:
 a46:	af 92       	push	r10
 a48:	bf 92       	push	r11
 a4a:	cf 92       	push	r12
 a4c:	df 92       	push	r13
 a4e:	ef 92       	push	r14
 a50:	ff 92       	push	r15
 a52:	0f 93       	push	r16
 a54:	a1 2c       	mov	r10, r1
 a56:	b1 2c       	mov	r11, r1
 a58:	c1 2c       	mov	r12, r1
 a5a:	d1 2c       	mov	r13, r1
 a5c:	e1 2c       	mov	r14, r1
 a5e:	f1 2c       	mov	r15, r1
 a60:	00 e0       	ldi	r16, 0x00	; 0
 a62:	20 e0       	ldi	r18, 0x00	; 0
 a64:	30 e0       	ldi	r19, 0x00	; 0
 a66:	45 e5       	ldi	r20, 0x55	; 85
 a68:	50 e0       	ldi	r21, 0x00	; 0
 a6a:	6c e1       	ldi	r22, 0x1C	; 28
 a6c:	71 e0       	ldi	r23, 0x01	; 1
 a6e:	8f ed       	ldi	r24, 0xDF	; 223
 a70:	96 e0       	ldi	r25, 0x06	; 6
 a72:	0e 94 c3 03 	call	0x786	; 0x786 <xTaskGenericCreate>
 a76:	81 30       	cpi	r24, 0x01	; 1
 a78:	49 f4       	brne	.+18     	; 0xa8c <vTaskStartScheduler+0x46>
 a7a:	f8 94       	cli
 a7c:	80 93 0c 07 	sts	0x070C, r24	; 0x80070c <xSchedulerRunning>
 a80:	10 92 0f 07 	sts	0x070F, r1	; 0x80070f <xTickCount+0x1>
 a84:	10 92 0e 07 	sts	0x070E, r1	; 0x80070e <xTickCount>
 a88:	0e 94 ae 01 	call	0x35c	; 0x35c <xPortStartScheduler>
 a8c:	0f 91       	pop	r16
 a8e:	ff 90       	pop	r15
 a90:	ef 90       	pop	r14
 a92:	df 90       	pop	r13
 a94:	cf 90       	pop	r12
 a96:	bf 90       	pop	r11
 a98:	af 90       	pop	r10
 a9a:	08 95       	ret

00000a9c <vTaskSuspendAll>:
 a9c:	80 91 07 07 	lds	r24, 0x0707	; 0x800707 <uxSchedulerSuspended>
 aa0:	8f 5f       	subi	r24, 0xFF	; 255
 aa2:	80 93 07 07 	sts	0x0707, r24	; 0x800707 <uxSchedulerSuspended>
 aa6:	08 95       	ret

00000aa8 <xTaskGetTickCount>:
 aa8:	0f b6       	in	r0, 0x3f	; 63
 aaa:	f8 94       	cli
 aac:	0f 92       	push	r0
 aae:	80 91 0e 07 	lds	r24, 0x070E	; 0x80070e <xTickCount>
 ab2:	90 91 0f 07 	lds	r25, 0x070F	; 0x80070f <xTickCount+0x1>
 ab6:	0f 90       	pop	r0
 ab8:	0f be       	out	0x3f, r0	; 63
 aba:	08 95       	ret

00000abc <xTaskIncrementTick>:
 abc:	cf 92       	push	r12
 abe:	df 92       	push	r13
 ac0:	ef 92       	push	r14
 ac2:	ff 92       	push	r15
 ac4:	0f 93       	push	r16
 ac6:	1f 93       	push	r17
 ac8:	cf 93       	push	r28
 aca:	df 93       	push	r29
 acc:	80 91 07 07 	lds	r24, 0x0707	; 0x800707 <uxSchedulerSuspended>
 ad0:	81 11       	cpse	r24, r1
 ad2:	9b c0       	rjmp	.+310    	; 0xc0a <xTaskIncrementTick+0x14e>
 ad4:	80 91 0e 07 	lds	r24, 0x070E	; 0x80070e <xTickCount>
 ad8:	90 91 0f 07 	lds	r25, 0x070F	; 0x80070f <xTickCount+0x1>
 adc:	01 96       	adiw	r24, 0x01	; 1
 ade:	90 93 0f 07 	sts	0x070F, r25	; 0x80070f <xTickCount+0x1>
 ae2:	80 93 0e 07 	sts	0x070E, r24	; 0x80070e <xTickCount>
 ae6:	e0 90 0e 07 	lds	r14, 0x070E	; 0x80070e <xTickCount>
 aea:	f0 90 0f 07 	lds	r15, 0x070F	; 0x80070f <xTickCount+0x1>
 aee:	e1 14       	cp	r14, r1
 af0:	f1 04       	cpc	r15, r1
 af2:	b9 f4       	brne	.+46     	; 0xb22 <xTaskIncrementTick+0x66>
 af4:	80 91 2f 07 	lds	r24, 0x072F	; 0x80072f <pxDelayedTaskList>
 af8:	90 91 30 07 	lds	r25, 0x0730	; 0x800730 <pxDelayedTaskList+0x1>
 afc:	20 91 2d 07 	lds	r18, 0x072D	; 0x80072d <pxOverflowDelayedTaskList>
 b00:	30 91 2e 07 	lds	r19, 0x072E	; 0x80072e <pxOverflowDelayedTaskList+0x1>
 b04:	30 93 30 07 	sts	0x0730, r19	; 0x800730 <pxDelayedTaskList+0x1>
 b08:	20 93 2f 07 	sts	0x072F, r18	; 0x80072f <pxDelayedTaskList>
 b0c:	90 93 2e 07 	sts	0x072E, r25	; 0x80072e <pxOverflowDelayedTaskList+0x1>
 b10:	80 93 2d 07 	sts	0x072D, r24	; 0x80072d <pxOverflowDelayedTaskList>
 b14:	80 91 09 07 	lds	r24, 0x0709	; 0x800709 <xNumOfOverflows>
 b18:	8f 5f       	subi	r24, 0xFF	; 255
 b1a:	80 93 09 07 	sts	0x0709, r24	; 0x800709 <xNumOfOverflows>
 b1e:	0e 94 6d 03 	call	0x6da	; 0x6da <prvResetNextTaskUnblockTime>
 b22:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <xNextTaskUnblockTime>
 b26:	90 91 03 01 	lds	r25, 0x0103	; 0x800103 <xNextTaskUnblockTime+0x1>
 b2a:	e8 16       	cp	r14, r24
 b2c:	f9 06       	cpc	r15, r25
 b2e:	10 f4       	brcc	.+4      	; 0xb34 <xTaskIncrementTick+0x78>
 b30:	d1 2c       	mov	r13, r1
 b32:	53 c0       	rjmp	.+166    	; 0xbda <xTaskIncrementTick+0x11e>
 b34:	d1 2c       	mov	r13, r1
 b36:	cc 24       	eor	r12, r12
 b38:	c3 94       	inc	r12
 b3a:	e0 91 2f 07 	lds	r30, 0x072F	; 0x80072f <pxDelayedTaskList>
 b3e:	f0 91 30 07 	lds	r31, 0x0730	; 0x800730 <pxDelayedTaskList+0x1>
 b42:	80 81       	ld	r24, Z
 b44:	81 11       	cpse	r24, r1
 b46:	07 c0       	rjmp	.+14     	; 0xb56 <xTaskIncrementTick+0x9a>
 b48:	8f ef       	ldi	r24, 0xFF	; 255
 b4a:	9f ef       	ldi	r25, 0xFF	; 255
 b4c:	90 93 03 01 	sts	0x0103, r25	; 0x800103 <xNextTaskUnblockTime+0x1>
 b50:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <xNextTaskUnblockTime>
 b54:	42 c0       	rjmp	.+132    	; 0xbda <xTaskIncrementTick+0x11e>
 b56:	e0 91 2f 07 	lds	r30, 0x072F	; 0x80072f <pxDelayedTaskList>
 b5a:	f0 91 30 07 	lds	r31, 0x0730	; 0x800730 <pxDelayedTaskList+0x1>
 b5e:	05 80       	ldd	r0, Z+5	; 0x05
 b60:	f6 81       	ldd	r31, Z+6	; 0x06
 b62:	e0 2d       	mov	r30, r0
 b64:	c6 81       	ldd	r28, Z+6	; 0x06
 b66:	d7 81       	ldd	r29, Z+7	; 0x07
 b68:	8a 81       	ldd	r24, Y+2	; 0x02
 b6a:	9b 81       	ldd	r25, Y+3	; 0x03
 b6c:	e8 16       	cp	r14, r24
 b6e:	f9 06       	cpc	r15, r25
 b70:	28 f4       	brcc	.+10     	; 0xb7c <xTaskIncrementTick+0xc0>
 b72:	90 93 03 01 	sts	0x0103, r25	; 0x800103 <xNextTaskUnblockTime+0x1>
 b76:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <xNextTaskUnblockTime>
 b7a:	2f c0       	rjmp	.+94     	; 0xbda <xTaskIncrementTick+0x11e>
 b7c:	8e 01       	movw	r16, r28
 b7e:	0e 5f       	subi	r16, 0xFE	; 254
 b80:	1f 4f       	sbci	r17, 0xFF	; 255
 b82:	c8 01       	movw	r24, r16
 b84:	0e 94 1c 01 	call	0x238	; 0x238 <uxListRemove>
 b88:	8c 89       	ldd	r24, Y+20	; 0x14
 b8a:	9d 89       	ldd	r25, Y+21	; 0x15
 b8c:	89 2b       	or	r24, r25
 b8e:	21 f0       	breq	.+8      	; 0xb98 <xTaskIncrementTick+0xdc>
 b90:	ce 01       	movw	r24, r28
 b92:	0c 96       	adiw	r24, 0x0c	; 12
 b94:	0e 94 1c 01 	call	0x238	; 0x238 <uxListRemove>
 b98:	8e 89       	ldd	r24, Y+22	; 0x16
 b9a:	90 91 0d 07 	lds	r25, 0x070D	; 0x80070d <uxTopReadyPriority>
 b9e:	98 17       	cp	r25, r24
 ba0:	10 f4       	brcc	.+4      	; 0xba6 <xTaskIncrementTick+0xea>
 ba2:	80 93 0d 07 	sts	0x070D, r24	; 0x80070d <uxTopReadyPriority>
 ba6:	90 e0       	ldi	r25, 0x00	; 0
 ba8:	9c 01       	movw	r18, r24
 baa:	22 0f       	add	r18, r18
 bac:	33 1f       	adc	r19, r19
 bae:	22 0f       	add	r18, r18
 bb0:	33 1f       	adc	r19, r19
 bb2:	22 0f       	add	r18, r18
 bb4:	33 1f       	adc	r19, r19
 bb6:	82 0f       	add	r24, r18
 bb8:	93 1f       	adc	r25, r19
 bba:	b8 01       	movw	r22, r16
 bbc:	8d 5b       	subi	r24, 0xBD	; 189
 bbe:	98 4f       	sbci	r25, 0xF8	; 248
 bc0:	0e 94 ca 00 	call	0x194	; 0x194 <vListInsertEnd>
 bc4:	e0 91 67 07 	lds	r30, 0x0767	; 0x800767 <pxCurrentTCB>
 bc8:	f0 91 68 07 	lds	r31, 0x0768	; 0x800768 <pxCurrentTCB+0x1>
 bcc:	9e 89       	ldd	r25, Y+22	; 0x16
 bce:	86 89       	ldd	r24, Z+22	; 0x16
 bd0:	98 17       	cp	r25, r24
 bd2:	08 f4       	brcc	.+2      	; 0xbd6 <xTaskIncrementTick+0x11a>
 bd4:	b2 cf       	rjmp	.-156    	; 0xb3a <xTaskIncrementTick+0x7e>
 bd6:	dc 2c       	mov	r13, r12
 bd8:	b0 cf       	rjmp	.-160    	; 0xb3a <xTaskIncrementTick+0x7e>
 bda:	e0 91 67 07 	lds	r30, 0x0767	; 0x800767 <pxCurrentTCB>
 bde:	f0 91 68 07 	lds	r31, 0x0768	; 0x800768 <pxCurrentTCB+0x1>
 be2:	86 89       	ldd	r24, Z+22	; 0x16
 be4:	90 e0       	ldi	r25, 0x00	; 0
 be6:	fc 01       	movw	r30, r24
 be8:	ee 0f       	add	r30, r30
 bea:	ff 1f       	adc	r31, r31
 bec:	ee 0f       	add	r30, r30
 bee:	ff 1f       	adc	r31, r31
 bf0:	ee 0f       	add	r30, r30
 bf2:	ff 1f       	adc	r31, r31
 bf4:	8e 0f       	add	r24, r30
 bf6:	9f 1f       	adc	r25, r31
 bf8:	fc 01       	movw	r30, r24
 bfa:	ed 5b       	subi	r30, 0xBD	; 189
 bfc:	f8 4f       	sbci	r31, 0xF8	; 248
 bfe:	80 81       	ld	r24, Z
 c00:	82 30       	cpi	r24, 0x02	; 2
 c02:	48 f0       	brcs	.+18     	; 0xc16 <xTaskIncrementTick+0x15a>
 c04:	dd 24       	eor	r13, r13
 c06:	d3 94       	inc	r13
 c08:	06 c0       	rjmp	.+12     	; 0xc16 <xTaskIncrementTick+0x15a>
 c0a:	80 91 0b 07 	lds	r24, 0x070B	; 0x80070b <uxPendedTicks>
 c0e:	8f 5f       	subi	r24, 0xFF	; 255
 c10:	80 93 0b 07 	sts	0x070B, r24	; 0x80070b <uxPendedTicks>
 c14:	d1 2c       	mov	r13, r1
 c16:	80 91 0a 07 	lds	r24, 0x070A	; 0x80070a <xYieldPending>
 c1a:	88 23       	and	r24, r24
 c1c:	11 f0       	breq	.+4      	; 0xc22 <xTaskIncrementTick+0x166>
 c1e:	dd 24       	eor	r13, r13
 c20:	d3 94       	inc	r13
 c22:	8d 2d       	mov	r24, r13
 c24:	df 91       	pop	r29
 c26:	cf 91       	pop	r28
 c28:	1f 91       	pop	r17
 c2a:	0f 91       	pop	r16
 c2c:	ff 90       	pop	r15
 c2e:	ef 90       	pop	r14
 c30:	df 90       	pop	r13
 c32:	cf 90       	pop	r12
 c34:	08 95       	ret

00000c36 <xTaskResumeAll>:
 c36:	df 92       	push	r13
 c38:	ef 92       	push	r14
 c3a:	ff 92       	push	r15
 c3c:	0f 93       	push	r16
 c3e:	1f 93       	push	r17
 c40:	cf 93       	push	r28
 c42:	df 93       	push	r29
 c44:	0f b6       	in	r0, 0x3f	; 63
 c46:	f8 94       	cli
 c48:	0f 92       	push	r0
 c4a:	80 91 07 07 	lds	r24, 0x0707	; 0x800707 <uxSchedulerSuspended>
 c4e:	81 50       	subi	r24, 0x01	; 1
 c50:	80 93 07 07 	sts	0x0707, r24	; 0x800707 <uxSchedulerSuspended>
 c54:	80 91 07 07 	lds	r24, 0x0707	; 0x800707 <uxSchedulerSuspended>
 c58:	81 11       	cpse	r24, r1
 c5a:	62 c0       	rjmp	.+196    	; 0xd20 <xTaskResumeAll+0xea>
 c5c:	80 91 10 07 	lds	r24, 0x0710	; 0x800710 <uxCurrentNumberOfTasks>
 c60:	81 11       	cpse	r24, r1
 c62:	33 c0       	rjmp	.+102    	; 0xcca <xTaskResumeAll+0x94>
 c64:	60 c0       	rjmp	.+192    	; 0xd26 <xTaskResumeAll+0xf0>
 c66:	d7 01       	movw	r26, r14
 c68:	15 96       	adiw	r26, 0x05	; 5
 c6a:	ed 91       	ld	r30, X+
 c6c:	fc 91       	ld	r31, X
 c6e:	16 97       	sbiw	r26, 0x06	; 6
 c70:	c6 81       	ldd	r28, Z+6	; 0x06
 c72:	d7 81       	ldd	r29, Z+7	; 0x07
 c74:	ce 01       	movw	r24, r28
 c76:	0c 96       	adiw	r24, 0x0c	; 12
 c78:	0e 94 1c 01 	call	0x238	; 0x238 <uxListRemove>
 c7c:	8e 01       	movw	r16, r28
 c7e:	0e 5f       	subi	r16, 0xFE	; 254
 c80:	1f 4f       	sbci	r17, 0xFF	; 255
 c82:	c8 01       	movw	r24, r16
 c84:	0e 94 1c 01 	call	0x238	; 0x238 <uxListRemove>
 c88:	8e 89       	ldd	r24, Y+22	; 0x16
 c8a:	90 91 0d 07 	lds	r25, 0x070D	; 0x80070d <uxTopReadyPriority>
 c8e:	98 17       	cp	r25, r24
 c90:	10 f4       	brcc	.+4      	; 0xc96 <xTaskResumeAll+0x60>
 c92:	80 93 0d 07 	sts	0x070D, r24	; 0x80070d <uxTopReadyPriority>
 c96:	90 e0       	ldi	r25, 0x00	; 0
 c98:	9c 01       	movw	r18, r24
 c9a:	22 0f       	add	r18, r18
 c9c:	33 1f       	adc	r19, r19
 c9e:	22 0f       	add	r18, r18
 ca0:	33 1f       	adc	r19, r19
 ca2:	22 0f       	add	r18, r18
 ca4:	33 1f       	adc	r19, r19
 ca6:	82 0f       	add	r24, r18
 ca8:	93 1f       	adc	r25, r19
 caa:	b8 01       	movw	r22, r16
 cac:	8d 5b       	subi	r24, 0xBD	; 189
 cae:	98 4f       	sbci	r25, 0xF8	; 248
 cb0:	0e 94 ca 00 	call	0x194	; 0x194 <vListInsertEnd>
 cb4:	e0 91 67 07 	lds	r30, 0x0767	; 0x800767 <pxCurrentTCB>
 cb8:	f0 91 68 07 	lds	r31, 0x0768	; 0x800768 <pxCurrentTCB+0x1>
 cbc:	9e 89       	ldd	r25, Y+22	; 0x16
 cbe:	86 89       	ldd	r24, Z+22	; 0x16
 cc0:	98 17       	cp	r25, r24
 cc2:	58 f0       	brcs	.+22     	; 0xcda <xTaskResumeAll+0xa4>
 cc4:	d0 92 0a 07 	sts	0x070A, r13	; 0x80070a <xYieldPending>
 cc8:	08 c0       	rjmp	.+16     	; 0xcda <xTaskResumeAll+0xa4>
 cca:	0f 2e       	mov	r0, r31
 ccc:	f4 e2       	ldi	r31, 0x24	; 36
 cce:	ef 2e       	mov	r14, r31
 cd0:	f7 e0       	ldi	r31, 0x07	; 7
 cd2:	ff 2e       	mov	r15, r31
 cd4:	f0 2d       	mov	r31, r0
 cd6:	dd 24       	eor	r13, r13
 cd8:	d3 94       	inc	r13
 cda:	f7 01       	movw	r30, r14
 cdc:	80 81       	ld	r24, Z
 cde:	81 11       	cpse	r24, r1
 ce0:	c2 cf       	rjmp	.-124    	; 0xc66 <xTaskResumeAll+0x30>
 ce2:	80 91 0b 07 	lds	r24, 0x070B	; 0x80070b <uxPendedTicks>
 ce6:	88 23       	and	r24, r24
 ce8:	99 f0       	breq	.+38     	; 0xd10 <xTaskResumeAll+0xda>
 cea:	80 91 0b 07 	lds	r24, 0x070B	; 0x80070b <uxPendedTicks>
 cee:	88 23       	and	r24, r24
 cf0:	79 f0       	breq	.+30     	; 0xd10 <xTaskResumeAll+0xda>
 cf2:	c1 e0       	ldi	r28, 0x01	; 1
 cf4:	0e 94 5e 05 	call	0xabc	; 0xabc <xTaskIncrementTick>
 cf8:	81 11       	cpse	r24, r1
 cfa:	c0 93 0a 07 	sts	0x070A, r28	; 0x80070a <xYieldPending>
 cfe:	80 91 0b 07 	lds	r24, 0x070B	; 0x80070b <uxPendedTicks>
 d02:	81 50       	subi	r24, 0x01	; 1
 d04:	80 93 0b 07 	sts	0x070B, r24	; 0x80070b <uxPendedTicks>
 d08:	80 91 0b 07 	lds	r24, 0x070B	; 0x80070b <uxPendedTicks>
 d0c:	81 11       	cpse	r24, r1
 d0e:	f2 cf       	rjmp	.-28     	; 0xcf4 <xTaskResumeAll+0xbe>
 d10:	80 91 0a 07 	lds	r24, 0x070A	; 0x80070a <xYieldPending>
 d14:	81 30       	cpi	r24, 0x01	; 1
 d16:	31 f4       	brne	.+12     	; 0xd24 <xTaskResumeAll+0xee>
 d18:	0e 94 e8 01 	call	0x3d0	; 0x3d0 <vPortYield>
 d1c:	81 e0       	ldi	r24, 0x01	; 1
 d1e:	03 c0       	rjmp	.+6      	; 0xd26 <xTaskResumeAll+0xf0>
 d20:	80 e0       	ldi	r24, 0x00	; 0
 d22:	01 c0       	rjmp	.+2      	; 0xd26 <xTaskResumeAll+0xf0>
 d24:	80 e0       	ldi	r24, 0x00	; 0
 d26:	0f 90       	pop	r0
 d28:	0f be       	out	0x3f, r0	; 63
 d2a:	df 91       	pop	r29
 d2c:	cf 91       	pop	r28
 d2e:	1f 91       	pop	r17
 d30:	0f 91       	pop	r16
 d32:	ff 90       	pop	r15
 d34:	ef 90       	pop	r14
 d36:	df 90       	pop	r13
 d38:	08 95       	ret

00000d3a <vTaskDelayUntil>:
 d3a:	0f 93       	push	r16
 d3c:	1f 93       	push	r17
 d3e:	cf 93       	push	r28
 d40:	df 93       	push	r29
 d42:	8c 01       	movw	r16, r24
 d44:	eb 01       	movw	r28, r22
 d46:	0e 94 4e 05 	call	0xa9c	; 0xa9c <vTaskSuspendAll>
 d4a:	20 91 0e 07 	lds	r18, 0x070E	; 0x80070e <xTickCount>
 d4e:	30 91 0f 07 	lds	r19, 0x070F	; 0x80070f <xTickCount+0x1>
 d52:	f8 01       	movw	r30, r16
 d54:	80 81       	ld	r24, Z
 d56:	91 81       	ldd	r25, Z+1	; 0x01
 d58:	c8 0f       	add	r28, r24
 d5a:	d9 1f       	adc	r29, r25
 d5c:	28 17       	cp	r18, r24
 d5e:	39 07       	cpc	r19, r25
 d60:	48 f4       	brcc	.+18     	; 0xd74 <vTaskDelayUntil+0x3a>
 d62:	c8 17       	cp	r28, r24
 d64:	d9 07       	cpc	r29, r25
 d66:	10 f5       	brcc	.+68     	; 0xdac <vTaskDelayUntil+0x72>
 d68:	d1 83       	std	Z+1, r29	; 0x01
 d6a:	c0 83       	st	Z, r28
 d6c:	2c 17       	cp	r18, r28
 d6e:	3d 07       	cpc	r19, r29
 d70:	90 f4       	brcc	.+36     	; 0xd96 <vTaskDelayUntil+0x5c>
 d72:	07 c0       	rjmp	.+14     	; 0xd82 <vTaskDelayUntil+0x48>
 d74:	c8 17       	cp	r28, r24
 d76:	d9 07       	cpc	r29, r25
 d78:	a8 f0       	brcs	.+42     	; 0xda4 <vTaskDelayUntil+0x6a>
 d7a:	2c 17       	cp	r18, r28
 d7c:	3d 07       	cpc	r19, r29
 d7e:	90 f0       	brcs	.+36     	; 0xda4 <vTaskDelayUntil+0x6a>
 d80:	15 c0       	rjmp	.+42     	; 0xdac <vTaskDelayUntil+0x72>
 d82:	80 91 67 07 	lds	r24, 0x0767	; 0x800767 <pxCurrentTCB>
 d86:	90 91 68 07 	lds	r25, 0x0768	; 0x800768 <pxCurrentTCB+0x1>
 d8a:	02 96       	adiw	r24, 0x02	; 2
 d8c:	0e 94 1c 01 	call	0x238	; 0x238 <uxListRemove>
 d90:	ce 01       	movw	r24, r28
 d92:	0e 94 8c 03 	call	0x718	; 0x718 <prvAddCurrentTaskToDelayedList>
 d96:	0e 94 1b 06 	call	0xc36	; 0xc36 <xTaskResumeAll>
 d9a:	81 11       	cpse	r24, r1
 d9c:	0b c0       	rjmp	.+22     	; 0xdb4 <vTaskDelayUntil+0x7a>
 d9e:	0e 94 e8 01 	call	0x3d0	; 0x3d0 <vPortYield>
 da2:	08 c0       	rjmp	.+16     	; 0xdb4 <vTaskDelayUntil+0x7a>
 da4:	f8 01       	movw	r30, r16
 da6:	d1 83       	std	Z+1, r29	; 0x01
 da8:	c0 83       	st	Z, r28
 daa:	eb cf       	rjmp	.-42     	; 0xd82 <vTaskDelayUntil+0x48>
 dac:	f8 01       	movw	r30, r16
 dae:	d1 83       	std	Z+1, r29	; 0x01
 db0:	c0 83       	st	Z, r28
 db2:	f1 cf       	rjmp	.-30     	; 0xd96 <vTaskDelayUntil+0x5c>
 db4:	df 91       	pop	r29
 db6:	cf 91       	pop	r28
 db8:	1f 91       	pop	r17
 dba:	0f 91       	pop	r16
 dbc:	08 95       	ret

00000dbe <prvIdleTask>:
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 dbe:	0b e1       	ldi	r16, 0x1B	; 27
 dc0:	17 e0       	ldi	r17, 0x07	; 7

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 dc2:	0f 2e       	mov	r0, r31
 dc4:	f3 e4       	ldi	r31, 0x43	; 67
 dc6:	ef 2e       	mov	r14, r31
 dc8:	f7 e0       	ldi	r31, 0x07	; 7
 dca:	ff 2e       	mov	r15, r31
 dcc:	f0 2d       	mov	r31, r0
 dce:	29 c0       	rjmp	.+82     	; 0xe22 <prvIdleTask+0x64>

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
 dd0:	0e 94 4e 05 	call	0xa9c	; 0xa9c <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 dd4:	d8 01       	movw	r26, r16
 dd6:	cc 91       	ld	r28, X
			}
			( void ) xTaskResumeAll();
 dd8:	0e 94 1b 06 	call	0xc36	; 0xc36 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
 ddc:	cc 23       	and	r28, r28
 dde:	09 f1       	breq	.+66     	; 0xe22 <prvIdleTask+0x64>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
 de0:	0f b6       	in	r0, 0x3f	; 63
 de2:	f8 94       	cli
 de4:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
 de6:	d8 01       	movw	r26, r16
 de8:	15 96       	adiw	r26, 0x05	; 5
 dea:	ed 91       	ld	r30, X+
 dec:	fc 91       	ld	r31, X
 dee:	16 97       	sbiw	r26, 0x06	; 6
 df0:	c6 81       	ldd	r28, Z+6	; 0x06
 df2:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 df4:	ce 01       	movw	r24, r28
 df6:	02 96       	adiw	r24, 0x02	; 2
 df8:	0e 94 1c 01 	call	0x238	; 0x238 <uxListRemove>
					--uxCurrentNumberOfTasks;
 dfc:	80 91 10 07 	lds	r24, 0x0710	; 0x800710 <uxCurrentNumberOfTasks>
 e00:	81 50       	subi	r24, 0x01	; 1
 e02:	80 93 10 07 	sts	0x0710, r24	; 0x800710 <uxCurrentNumberOfTasks>
					--uxTasksDeleted;
 e06:	80 91 1a 07 	lds	r24, 0x071A	; 0x80071a <uxTasksDeleted>
 e0a:	81 50       	subi	r24, 0x01	; 1
 e0c:	80 93 1a 07 	sts	0x071A, r24	; 0x80071a <uxTasksDeleted>
				}
				taskEXIT_CRITICAL();
 e10:	0f 90       	pop	r0
 e12:	0f be       	out	0x3f, r0	; 63
				vPortFreeAligned( pxTCB->pxStack );
			}
		}
		#else
		{
			vPortFreeAligned( pxTCB->pxStack );
 e14:	8f 89       	ldd	r24, Y+23	; 0x17
 e16:	98 8d       	ldd	r25, Y+24	; 0x18
 e18:	0e 94 3a 03 	call	0x674	; 0x674 <vPortFree>
		}
		#endif

		vPortFree( pxTCB );
 e1c:	ce 01       	movw	r24, r28
 e1e:	0e 94 3a 03 	call	0x674	; 0x674 <vPortFree>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
 e22:	80 91 1a 07 	lds	r24, 0x071A	; 0x80071a <uxTasksDeleted>
 e26:	81 11       	cpse	r24, r1
 e28:	d3 cf       	rjmp	.-90     	; 0xdd0 <prvIdleTask+0x12>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 e2a:	f7 01       	movw	r30, r14
 e2c:	80 81       	ld	r24, Z
 e2e:	82 30       	cpi	r24, 0x02	; 2
 e30:	c0 f3       	brcs	.-16     	; 0xe22 <prvIdleTask+0x64>
			{
				taskYIELD();
 e32:	0e 94 e8 01 	call	0x3d0	; 0x3d0 <vPortYield>
 e36:	f5 cf       	rjmp	.-22     	; 0xe22 <prvIdleTask+0x64>

00000e38 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 e38:	80 91 07 07 	lds	r24, 0x0707	; 0x800707 <uxSchedulerSuspended>
 e3c:	88 23       	and	r24, r24
 e3e:	21 f0       	breq	.+8      	; 0xe48 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
 e40:	81 e0       	ldi	r24, 0x01	; 1
 e42:	80 93 0a 07 	sts	0x070A, r24	; 0x80070a <xYieldPending>
 e46:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
 e48:	10 92 0a 07 	sts	0x070A, r1	; 0x80070a <xYieldPending>
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
 e4c:	80 91 0d 07 	lds	r24, 0x070D	; 0x80070d <uxTopReadyPriority>
 e50:	90 e0       	ldi	r25, 0x00	; 0
 e52:	fc 01       	movw	r30, r24
 e54:	ee 0f       	add	r30, r30
 e56:	ff 1f       	adc	r31, r31
 e58:	ee 0f       	add	r30, r30
 e5a:	ff 1f       	adc	r31, r31
 e5c:	ee 0f       	add	r30, r30
 e5e:	ff 1f       	adc	r31, r31
 e60:	8e 0f       	add	r24, r30
 e62:	9f 1f       	adc	r25, r31
 e64:	fc 01       	movw	r30, r24
 e66:	ed 5b       	subi	r30, 0xBD	; 189
 e68:	f8 4f       	sbci	r31, 0xF8	; 248
 e6a:	80 81       	ld	r24, Z
 e6c:	81 11       	cpse	r24, r1
 e6e:	17 c0       	rjmp	.+46     	; 0xe9e <vTaskSwitchContext+0x66>
 e70:	80 91 0d 07 	lds	r24, 0x070D	; 0x80070d <uxTopReadyPriority>
 e74:	81 50       	subi	r24, 0x01	; 1
 e76:	80 93 0d 07 	sts	0x070D, r24	; 0x80070d <uxTopReadyPriority>
 e7a:	80 91 0d 07 	lds	r24, 0x070D	; 0x80070d <uxTopReadyPriority>
 e7e:	90 e0       	ldi	r25, 0x00	; 0
 e80:	fc 01       	movw	r30, r24
 e82:	ee 0f       	add	r30, r30
 e84:	ff 1f       	adc	r31, r31
 e86:	ee 0f       	add	r30, r30
 e88:	ff 1f       	adc	r31, r31
 e8a:	ee 0f       	add	r30, r30
 e8c:	ff 1f       	adc	r31, r31
 e8e:	8e 0f       	add	r24, r30
 e90:	9f 1f       	adc	r25, r31
 e92:	fc 01       	movw	r30, r24
 e94:	ed 5b       	subi	r30, 0xBD	; 189
 e96:	f8 4f       	sbci	r31, 0xF8	; 248
 e98:	80 81       	ld	r24, Z
 e9a:	88 23       	and	r24, r24
 e9c:	49 f3       	breq	.-46     	; 0xe70 <vTaskSwitchContext+0x38>
 e9e:	80 91 0d 07 	lds	r24, 0x070D	; 0x80070d <uxTopReadyPriority>
 ea2:	90 e0       	ldi	r25, 0x00	; 0
 ea4:	9c 01       	movw	r18, r24
 ea6:	22 0f       	add	r18, r18
 ea8:	33 1f       	adc	r19, r19
 eaa:	22 0f       	add	r18, r18
 eac:	33 1f       	adc	r19, r19
 eae:	22 0f       	add	r18, r18
 eb0:	33 1f       	adc	r19, r19
 eb2:	28 0f       	add	r18, r24
 eb4:	39 1f       	adc	r19, r25
 eb6:	d9 01       	movw	r26, r18
 eb8:	ad 5b       	subi	r26, 0xBD	; 189
 eba:	b8 4f       	sbci	r27, 0xF8	; 248
 ebc:	11 96       	adiw	r26, 0x01	; 1
 ebe:	ed 91       	ld	r30, X+
 ec0:	fc 91       	ld	r31, X
 ec2:	12 97       	sbiw	r26, 0x02	; 2
 ec4:	02 80       	ldd	r0, Z+2	; 0x02
 ec6:	f3 81       	ldd	r31, Z+3	; 0x03
 ec8:	e0 2d       	mov	r30, r0
 eca:	12 96       	adiw	r26, 0x02	; 2
 ecc:	fc 93       	st	X, r31
 ece:	ee 93       	st	-X, r30
 ed0:	11 97       	sbiw	r26, 0x01	; 1
 ed2:	2a 5b       	subi	r18, 0xBA	; 186
 ed4:	38 4f       	sbci	r19, 0xF8	; 248
 ed6:	e2 17       	cp	r30, r18
 ed8:	f3 07       	cpc	r31, r19
 eda:	29 f4       	brne	.+10     	; 0xee6 <vTaskSwitchContext+0xae>
 edc:	22 81       	ldd	r18, Z+2	; 0x02
 ede:	33 81       	ldd	r19, Z+3	; 0x03
 ee0:	fd 01       	movw	r30, r26
 ee2:	32 83       	std	Z+2, r19	; 0x02
 ee4:	21 83       	std	Z+1, r18	; 0x01
 ee6:	fc 01       	movw	r30, r24
 ee8:	ee 0f       	add	r30, r30
 eea:	ff 1f       	adc	r31, r31
 eec:	ee 0f       	add	r30, r30
 eee:	ff 1f       	adc	r31, r31
 ef0:	ee 0f       	add	r30, r30
 ef2:	ff 1f       	adc	r31, r31
 ef4:	8e 0f       	add	r24, r30
 ef6:	9f 1f       	adc	r25, r31
 ef8:	fc 01       	movw	r30, r24
 efa:	ed 5b       	subi	r30, 0xBD	; 189
 efc:	f8 4f       	sbci	r31, 0xF8	; 248
 efe:	01 80       	ldd	r0, Z+1	; 0x01
 f00:	f2 81       	ldd	r31, Z+2	; 0x02
 f02:	e0 2d       	mov	r30, r0
 f04:	86 81       	ldd	r24, Z+6	; 0x06
 f06:	97 81       	ldd	r25, Z+7	; 0x07
 f08:	90 93 68 07 	sts	0x0768, r25	; 0x800768 <pxCurrentTCB+0x1>
 f0c:	80 93 67 07 	sts	0x0767, r24	; 0x800767 <pxCurrentTCB>
 f10:	08 95       	ret

00000f12 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
 f12:	0f 93       	push	r16
 f14:	1f 93       	push	r17
 f16:	cf 93       	push	r28
 f18:	df 93       	push	r29
 f1a:	ec 01       	movw	r28, r24
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
 f1c:	0f b6       	in	r0, 0x3f	; 63
 f1e:	f8 94       	cli
 f20:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
 f22:	89 2b       	or	r24, r25
 f24:	21 f4       	brne	.+8      	; 0xf2e <vTaskSuspend+0x1c>
 f26:	c0 91 67 07 	lds	r28, 0x0767	; 0x800767 <pxCurrentTCB>
 f2a:	d0 91 68 07 	lds	r29, 0x0768	; 0x800768 <pxCurrentTCB+0x1>

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 f2e:	8e 01       	movw	r16, r28
 f30:	0e 5f       	subi	r16, 0xFE	; 254
 f32:	1f 4f       	sbci	r17, 0xFF	; 255
 f34:	c8 01       	movw	r24, r16
 f36:	0e 94 1c 01 	call	0x238	; 0x238 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 f3a:	8c 89       	ldd	r24, Y+20	; 0x14
 f3c:	9d 89       	ldd	r25, Y+21	; 0x15
 f3e:	89 2b       	or	r24, r25
 f40:	21 f0       	breq	.+8      	; 0xf4a <vTaskSuspend+0x38>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 f42:	ce 01       	movw	r24, r28
 f44:	0c 96       	adiw	r24, 0x0c	; 12
 f46:	0e 94 1c 01 	call	0x238	; 0x238 <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
 f4a:	b8 01       	movw	r22, r16
 f4c:	81 e1       	ldi	r24, 0x11	; 17
 f4e:	97 e0       	ldi	r25, 0x07	; 7
 f50:	0e 94 ca 00 	call	0x194	; 0x194 <vListInsertEnd>
		}
		taskEXIT_CRITICAL();
 f54:	0f 90       	pop	r0
 f56:	0f be       	out	0x3f, r0	; 63

		if( pxTCB == pxCurrentTCB )
 f58:	80 91 67 07 	lds	r24, 0x0767	; 0x800767 <pxCurrentTCB>
 f5c:	90 91 68 07 	lds	r25, 0x0768	; 0x800768 <pxCurrentTCB+0x1>
 f60:	c8 17       	cp	r28, r24
 f62:	d9 07       	cpc	r29, r25
 f64:	a9 f4       	brne	.+42     	; 0xf90 <vTaskSuspend+0x7e>
		{
			if( xSchedulerRunning != pdFALSE )
 f66:	80 91 0c 07 	lds	r24, 0x070C	; 0x80070c <xSchedulerRunning>
 f6a:	88 23       	and	r24, r24
 f6c:	19 f0       	breq	.+6      	; 0xf74 <vTaskSuspend+0x62>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
 f6e:	0e 94 e8 01 	call	0x3d0	; 0x3d0 <vPortYield>
 f72:	19 c0       	rjmp	.+50     	; 0xfa6 <vTaskSuspend+0x94>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
 f74:	80 91 10 07 	lds	r24, 0x0710	; 0x800710 <uxCurrentNumberOfTasks>
 f78:	90 91 11 07 	lds	r25, 0x0711	; 0x800711 <xSuspendedTaskList>
 f7c:	98 13       	cpse	r25, r24
 f7e:	05 c0       	rjmp	.+10     	; 0xf8a <vTaskSuspend+0x78>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
 f80:	10 92 68 07 	sts	0x0768, r1	; 0x800768 <pxCurrentTCB+0x1>
 f84:	10 92 67 07 	sts	0x0767, r1	; 0x800767 <pxCurrentTCB>
 f88:	0e c0       	rjmp	.+28     	; 0xfa6 <vTaskSuspend+0x94>
				}
				else
				{
					vTaskSwitchContext();
 f8a:	0e 94 1c 07 	call	0xe38	; 0xe38 <vTaskSwitchContext>
 f8e:	0b c0       	rjmp	.+22     	; 0xfa6 <vTaskSuspend+0x94>
				}
			}
		}
		else
		{
			if( xSchedulerRunning != pdFALSE )
 f90:	80 91 0c 07 	lds	r24, 0x070C	; 0x80070c <xSchedulerRunning>
 f94:	88 23       	and	r24, r24
 f96:	39 f0       	breq	.+14     	; 0xfa6 <vTaskSuspend+0x94>
			{
				/* A task other than the currently running task was suspended,
				reset the next expected unblock time in case it referred to the
				task that is now in the Suspended state. */
				taskENTER_CRITICAL();
 f98:	0f b6       	in	r0, 0x3f	; 63
 f9a:	f8 94       	cli
 f9c:	0f 92       	push	r0
				{
					prvResetNextTaskUnblockTime();
 f9e:	0e 94 6d 03 	call	0x6da	; 0x6da <prvResetNextTaskUnblockTime>
				}
				taskEXIT_CRITICAL();
 fa2:	0f 90       	pop	r0
 fa4:	0f be       	out	0x3f, r0	; 63
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
 fa6:	df 91       	pop	r29
 fa8:	cf 91       	pop	r28
 faa:	1f 91       	pop	r17
 fac:	0f 91       	pop	r16
 fae:	08 95       	ret

00000fb0 <_exit>:
 fb0:	f8 94       	cli

00000fb2 <__stop_program>:
 fb2:	ff cf       	rjmp	.-2      	; 0xfb2 <__stop_program>
