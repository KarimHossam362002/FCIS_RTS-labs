
ArduinoUnoFreertos_6_1.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000014  00800100  00000dce  00000e62  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000dce  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000063e  00800114  00800114  00000e76  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000e76  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000ea8  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000001f0  00000000  00000000  00000ee8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00002890  00000000  00000000  000010d8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000d91  00000000  00000000  00003968  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001de6  00000000  00000000  000046f9  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000005b8  00000000  00000000  000064e0  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000c17f  00000000  00000000  00006a98  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00002010  00000000  00000000  00012c17  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000218  00000000  00000000  00014c27  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  000035be  00000000  00000000  00014e3f  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	33 c0       	rjmp	.+102    	; 0x68 <__ctors_end>
   2:	00 00       	nop
   4:	4c c0       	rjmp	.+152    	; 0x9e <__bad_interrupt>
   6:	00 00       	nop
   8:	4a c0       	rjmp	.+148    	; 0x9e <__bad_interrupt>
   a:	00 00       	nop
   c:	48 c0       	rjmp	.+144    	; 0x9e <__bad_interrupt>
   e:	00 00       	nop
  10:	46 c0       	rjmp	.+140    	; 0x9e <__bad_interrupt>
  12:	00 00       	nop
  14:	44 c0       	rjmp	.+136    	; 0x9e <__bad_interrupt>
  16:	00 00       	nop
  18:	42 c0       	rjmp	.+132    	; 0x9e <__bad_interrupt>
  1a:	00 00       	nop
  1c:	40 c0       	rjmp	.+128    	; 0x9e <__bad_interrupt>
  1e:	00 00       	nop
  20:	3e c0       	rjmp	.+124    	; 0x9e <__bad_interrupt>
  22:	00 00       	nop
  24:	3c c0       	rjmp	.+120    	; 0x9e <__bad_interrupt>
  26:	00 00       	nop
  28:	3a c0       	rjmp	.+116    	; 0x9e <__bad_interrupt>
  2a:	00 00       	nop
  2c:	63 c2       	rjmp	.+1222   	; 0x4f4 <__vector_11>
  2e:	00 00       	nop
  30:	36 c0       	rjmp	.+108    	; 0x9e <__bad_interrupt>
  32:	00 00       	nop
  34:	34 c0       	rjmp	.+104    	; 0x9e <__bad_interrupt>
  36:	00 00       	nop
  38:	32 c0       	rjmp	.+100    	; 0x9e <__bad_interrupt>
  3a:	00 00       	nop
  3c:	30 c0       	rjmp	.+96     	; 0x9e <__bad_interrupt>
  3e:	00 00       	nop
  40:	2e c0       	rjmp	.+92     	; 0x9e <__bad_interrupt>
  42:	00 00       	nop
  44:	2c c0       	rjmp	.+88     	; 0x9e <__bad_interrupt>
  46:	00 00       	nop
  48:	2a c0       	rjmp	.+84     	; 0x9e <__bad_interrupt>
  4a:	00 00       	nop
  4c:	28 c0       	rjmp	.+80     	; 0x9e <__bad_interrupt>
  4e:	00 00       	nop
  50:	26 c0       	rjmp	.+76     	; 0x9e <__bad_interrupt>
  52:	00 00       	nop
  54:	24 c0       	rjmp	.+72     	; 0x9e <__bad_interrupt>
  56:	00 00       	nop
  58:	22 c0       	rjmp	.+68     	; 0x9e <__bad_interrupt>
  5a:	00 00       	nop
  5c:	20 c0       	rjmp	.+64     	; 0x9e <__bad_interrupt>
  5e:	00 00       	nop
  60:	1e c0       	rjmp	.+60     	; 0x9e <__bad_interrupt>
  62:	00 00       	nop
  64:	1c c0       	rjmp	.+56     	; 0x9e <__bad_interrupt>
	...

00000068 <__ctors_end>:
  68:	11 24       	eor	r1, r1
  6a:	1f be       	out	0x3f, r1	; 63
  6c:	cf ef       	ldi	r28, 0xFF	; 255
  6e:	d8 e0       	ldi	r29, 0x08	; 8
  70:	de bf       	out	0x3e, r29	; 62
  72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
  74:	11 e0       	ldi	r17, 0x01	; 1
  76:	a0 e0       	ldi	r26, 0x00	; 0
  78:	b1 e0       	ldi	r27, 0x01	; 1
  7a:	ee ec       	ldi	r30, 0xCE	; 206
  7c:	fd e0       	ldi	r31, 0x0D	; 13
  7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
  80:	05 90       	lpm	r0, Z+
  82:	0d 92       	st	X+, r0
  84:	a4 31       	cpi	r26, 0x14	; 20
  86:	b1 07       	cpc	r27, r17
  88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
  8a:	27 e0       	ldi	r18, 0x07	; 7
  8c:	a4 e1       	ldi	r26, 0x14	; 20
  8e:	b1 e0       	ldi	r27, 0x01	; 1
  90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
  92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
  94:	a2 35       	cpi	r26, 0x52	; 82
  96:	b2 07       	cpc	r27, r18
  98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
  9a:	2c d0       	rcall	.+88     	; 0xf4 <main>
  9c:	96 c6       	rjmp	.+3372   	; 0xdca <_exit>

0000009e <__bad_interrupt>:
  9e:	b0 cf       	rjmp	.-160    	; 0x0 <__vectors>

000000a0 <vLED1Toggle>:
	for (;;);
	return 0;
}

// Task 1
void vLED1Toggle(void *pvParameters){
  a0:	cf 93       	push	r28
  a2:	df 93       	push	r29
  a4:	00 d0       	rcall	.+0      	; 0xa6 <vLED1Toggle+0x6>
  a6:	cd b7       	in	r28, 0x3d	; 61
  a8:	de b7       	in	r29, 0x3e	; 62
	TickType_t xLastWakeTime = xTaskGetTickCount();
  aa:	6e d4       	rcall	.+2268   	; 0x988 <xTaskGetTickCount>
  ac:	9a 83       	std	Y+2, r25	; 0x02
  ae:	89 83       	std	Y+1, r24	; 0x01
	while(1){
		PORTB |= (1<<PORTB3);   // LED1 ON
  b0:	2b 9a       	sbi	0x05, 3	; 5
		vTaskDelayUntil(&xLastWakeTime, pdMS_TO_TICKS(100));
  b2:	62 e2       	ldi	r22, 0x22	; 34
  b4:	70 e0       	ldi	r23, 0x00	; 0
  b6:	ce 01       	movw	r24, r28
  b8:	01 96       	adiw	r24, 0x01	; 1
  ba:	a6 d5       	rcall	.+2892   	; 0xc08 <vTaskDelayUntil>
		PORTB &= ~(1<<PORTB3);  // LED1 OFF
  bc:	2b 98       	cbi	0x05, 3	; 5
		vTaskDelayUntil(&xLastWakeTime, pdMS_TO_TICKS(100));
  be:	62 e2       	ldi	r22, 0x22	; 34
  c0:	70 e0       	ldi	r23, 0x00	; 0
  c2:	ce 01       	movw	r24, r28
  c4:	01 96       	adiw	r24, 0x01	; 1
  c6:	a0 d5       	rcall	.+2880   	; 0xc08 <vTaskDelayUntil>
  c8:	f3 cf       	rjmp	.-26     	; 0xb0 <vLED1Toggle+0x10>

000000ca <vLED2Toggle>:
	}
}

// Task 2
void vLED2Toggle(void *pvParameters){
  ca:	cf 93       	push	r28
  cc:	df 93       	push	r29
  ce:	00 d0       	rcall	.+0      	; 0xd0 <vLED2Toggle+0x6>
  d0:	cd b7       	in	r28, 0x3d	; 61
  d2:	de b7       	in	r29, 0x3e	; 62
	TickType_t xLastWakeTime = xTaskGetTickCount();
  d4:	59 d4       	rcall	.+2226   	; 0x988 <xTaskGetTickCount>
  d6:	9a 83       	std	Y+2, r25	; 0x02
  d8:	89 83       	std	Y+1, r24	; 0x01
	while(1){
		PORTB |= (1<<PORTB5);   // LED2 ON
  da:	2d 9a       	sbi	0x05, 5	; 5
		vTaskDelayUntil(&xLastWakeTime, pdMS_TO_TICKS(100));
  dc:	62 e2       	ldi	r22, 0x22	; 34
  de:	70 e0       	ldi	r23, 0x00	; 0
  e0:	ce 01       	movw	r24, r28
  e2:	01 96       	adiw	r24, 0x01	; 1
  e4:	91 d5       	rcall	.+2850   	; 0xc08 <vTaskDelayUntil>
		PORTB &= ~(1<<PORTB5);  // LED2 OFF
  e6:	2d 98       	cbi	0x05, 5	; 5
		vTaskDelayUntil(&xLastWakeTime, pdMS_TO_TICKS(100));
  e8:	62 e2       	ldi	r22, 0x22	; 34
  ea:	70 e0       	ldi	r23, 0x00	; 0
  ec:	ce 01       	movw	r24, r28
  ee:	01 96       	adiw	r24, 0x01	; 1
  f0:	8b d5       	rcall	.+2838   	; 0xc08 <vTaskDelayUntil>
  f2:	f3 cf       	rjmp	.-26     	; 0xda <vLED2Toggle+0x10>

000000f4 <main>:
void vLED1Toggle(void *pvParameters);
void vLED2Toggle(void *pvParameters);

int main(void)
{
	DDRB = 0xFF; // PORTB as output
  f4:	8f ef       	ldi	r24, 0xFF	; 255
  f6:	84 b9       	out	0x04, r24	; 4

	xTaskCreate(vLED1Toggle, "LED1", 256, NULL, 1, NULL);
  f8:	a1 2c       	mov	r10, r1
  fa:	b1 2c       	mov	r11, r1
  fc:	c1 2c       	mov	r12, r1
  fe:	d1 2c       	mov	r13, r1
 100:	e1 2c       	mov	r14, r1
 102:	f1 2c       	mov	r15, r1
 104:	01 e0       	ldi	r16, 0x01	; 1
 106:	20 e0       	ldi	r18, 0x00	; 0
 108:	30 e0       	ldi	r19, 0x00	; 0
 10a:	40 e0       	ldi	r20, 0x00	; 0
 10c:	51 e0       	ldi	r21, 0x01	; 1
 10e:	64 e0       	ldi	r22, 0x04	; 4
 110:	71 e0       	ldi	r23, 0x01	; 1
 112:	80 e5       	ldi	r24, 0x50	; 80
 114:	90 e0       	ldi	r25, 0x00	; 0
 116:	0d d3       	rcall	.+1562   	; 0x732 <xTaskGenericCreate>
	xTaskCreate(vLED2Toggle, "LED2", 256, NULL, 2, NULL);
 118:	02 e0       	ldi	r16, 0x02	; 2
 11a:	20 e0       	ldi	r18, 0x00	; 0
 11c:	30 e0       	ldi	r19, 0x00	; 0
 11e:	40 e0       	ldi	r20, 0x00	; 0
 120:	51 e0       	ldi	r21, 0x01	; 1
 122:	69 e0       	ldi	r22, 0x09	; 9
 124:	71 e0       	ldi	r23, 0x01	; 1
 126:	85 e6       	ldi	r24, 0x65	; 101
 128:	90 e0       	ldi	r25, 0x00	; 0

	vTaskStartScheduler();
 12a:	03 d3       	rcall	.+1542   	; 0x732 <xTaskGenericCreate>
 12c:	fe d3       	rcall	.+2044   	; 0x92a <vTaskStartScheduler>
 12e:	ff cf       	rjmp	.-2      	; 0x12e <main+0x3a>

00000130 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
 130:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 132:	03 96       	adiw	r24, 0x03	; 3
 134:	92 83       	std	Z+2, r25	; 0x02
 136:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 138:	2f ef       	ldi	r18, 0xFF	; 255
 13a:	3f ef       	ldi	r19, 0xFF	; 255
 13c:	34 83       	std	Z+4, r19	; 0x04
 13e:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 140:	96 83       	std	Z+6, r25	; 0x06
 142:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 144:	90 87       	std	Z+8, r25	; 0x08
 146:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 148:	10 82       	st	Z, r1
 14a:	08 95       	ret

0000014c <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 14c:	fc 01       	movw	r30, r24
 14e:	11 86       	std	Z+9, r1	; 0x09
 150:	10 86       	std	Z+8, r1	; 0x08
 152:	08 95       	ret

00000154 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 154:	cf 93       	push	r28
 156:	df 93       	push	r29
 158:	9c 01       	movw	r18, r24
 15a:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
 15c:	dc 01       	movw	r26, r24
 15e:	11 96       	adiw	r26, 0x01	; 1
 160:	cd 91       	ld	r28, X+
 162:	dc 91       	ld	r29, X
 164:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
 166:	d3 83       	std	Z+3, r29	; 0x03
 168:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 16a:	8c 81       	ldd	r24, Y+4	; 0x04
 16c:	9d 81       	ldd	r25, Y+5	; 0x05
 16e:	95 83       	std	Z+5, r25	; 0x05
 170:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
 172:	8c 81       	ldd	r24, Y+4	; 0x04
 174:	9d 81       	ldd	r25, Y+5	; 0x05
 176:	dc 01       	movw	r26, r24
 178:	13 96       	adiw	r26, 0x03	; 3
 17a:	7c 93       	st	X, r23
 17c:	6e 93       	st	-X, r22
 17e:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
 180:	7d 83       	std	Y+5, r23	; 0x05
 182:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 184:	31 87       	std	Z+9, r19	; 0x09
 186:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
 188:	f9 01       	movw	r30, r18
 18a:	80 81       	ld	r24, Z
 18c:	8f 5f       	subi	r24, 0xFF	; 255
 18e:	80 83       	st	Z, r24
}
 190:	df 91       	pop	r29
 192:	cf 91       	pop	r28
 194:	08 95       	ret

00000196 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 196:	cf 93       	push	r28
 198:	df 93       	push	r29
 19a:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 19c:	48 81       	ld	r20, Y
 19e:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 1a0:	4f 3f       	cpi	r20, 0xFF	; 255
 1a2:	2f ef       	ldi	r18, 0xFF	; 255
 1a4:	52 07       	cpc	r21, r18
 1a6:	21 f4       	brne	.+8      	; 0x1b0 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 1a8:	fc 01       	movw	r30, r24
 1aa:	a7 81       	ldd	r26, Z+7	; 0x07
 1ac:	b0 85       	ldd	r27, Z+8	; 0x08
 1ae:	0d c0       	rjmp	.+26     	; 0x1ca <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 1b0:	dc 01       	movw	r26, r24
 1b2:	13 96       	adiw	r26, 0x03	; 3
 1b4:	01 c0       	rjmp	.+2      	; 0x1b8 <vListInsert+0x22>
 1b6:	df 01       	movw	r26, r30
 1b8:	12 96       	adiw	r26, 0x02	; 2
 1ba:	ed 91       	ld	r30, X+
 1bc:	fc 91       	ld	r31, X
 1be:	13 97       	sbiw	r26, 0x03	; 3
 1c0:	20 81       	ld	r18, Z
 1c2:	31 81       	ldd	r19, Z+1	; 0x01
 1c4:	42 17       	cp	r20, r18
 1c6:	53 07       	cpc	r21, r19
 1c8:	b0 f7       	brcc	.-20     	; 0x1b6 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 1ca:	12 96       	adiw	r26, 0x02	; 2
 1cc:	ed 91       	ld	r30, X+
 1ce:	fc 91       	ld	r31, X
 1d0:	13 97       	sbiw	r26, 0x03	; 3
 1d2:	fb 83       	std	Y+3, r31	; 0x03
 1d4:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 1d6:	d5 83       	std	Z+5, r29	; 0x05
 1d8:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
 1da:	bd 83       	std	Y+5, r27	; 0x05
 1dc:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
 1de:	13 96       	adiw	r26, 0x03	; 3
 1e0:	dc 93       	st	X, r29
 1e2:	ce 93       	st	-X, r28
 1e4:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 1e6:	99 87       	std	Y+9, r25	; 0x09
 1e8:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
 1ea:	fc 01       	movw	r30, r24
 1ec:	20 81       	ld	r18, Z
 1ee:	2f 5f       	subi	r18, 0xFF	; 255
 1f0:	20 83       	st	Z, r18
}
 1f2:	df 91       	pop	r29
 1f4:	cf 91       	pop	r28
 1f6:	08 95       	ret

000001f8 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
 1f8:	cf 93       	push	r28
 1fa:	df 93       	push	r29
 1fc:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
 1fe:	a0 85       	ldd	r26, Z+8	; 0x08
 200:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 202:	c2 81       	ldd	r28, Z+2	; 0x02
 204:	d3 81       	ldd	r29, Z+3	; 0x03
 206:	84 81       	ldd	r24, Z+4	; 0x04
 208:	95 81       	ldd	r25, Z+5	; 0x05
 20a:	9d 83       	std	Y+5, r25	; 0x05
 20c:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 20e:	c4 81       	ldd	r28, Z+4	; 0x04
 210:	d5 81       	ldd	r29, Z+5	; 0x05
 212:	82 81       	ldd	r24, Z+2	; 0x02
 214:	93 81       	ldd	r25, Z+3	; 0x03
 216:	9b 83       	std	Y+3, r25	; 0x03
 218:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 21a:	11 96       	adiw	r26, 0x01	; 1
 21c:	8d 91       	ld	r24, X+
 21e:	9c 91       	ld	r25, X
 220:	12 97       	sbiw	r26, 0x02	; 2
 222:	e8 17       	cp	r30, r24
 224:	f9 07       	cpc	r31, r25
 226:	31 f4       	brne	.+12     	; 0x234 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 228:	84 81       	ldd	r24, Z+4	; 0x04
 22a:	95 81       	ldd	r25, Z+5	; 0x05
 22c:	12 96       	adiw	r26, 0x02	; 2
 22e:	9c 93       	st	X, r25
 230:	8e 93       	st	-X, r24
 232:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
 234:	11 86       	std	Z+9, r1	; 0x09
 236:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
 238:	8c 91       	ld	r24, X
 23a:	81 50       	subi	r24, 0x01	; 1
 23c:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
 23e:	df 91       	pop	r29
 240:	cf 91       	pop	r28
 242:	08 95       	ret

00000244 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
 244:	31 e1       	ldi	r19, 0x11	; 17
 246:	fc 01       	movw	r30, r24
 248:	30 83       	st	Z, r19
 24a:	31 97       	sbiw	r30, 0x01	; 1
 24c:	22 e2       	ldi	r18, 0x22	; 34
 24e:	20 83       	st	Z, r18
 250:	31 97       	sbiw	r30, 0x01	; 1
 252:	a3 e3       	ldi	r26, 0x33	; 51
 254:	a0 83       	st	Z, r26
 256:	31 97       	sbiw	r30, 0x01	; 1
 258:	60 83       	st	Z, r22
 25a:	31 97       	sbiw	r30, 0x01	; 1
 25c:	70 83       	st	Z, r23
 25e:	31 97       	sbiw	r30, 0x01	; 1
 260:	10 82       	st	Z, r1
 262:	31 97       	sbiw	r30, 0x01	; 1
 264:	60 e8       	ldi	r22, 0x80	; 128
 266:	60 83       	st	Z, r22
 268:	31 97       	sbiw	r30, 0x01	; 1
 26a:	10 82       	st	Z, r1
 26c:	31 97       	sbiw	r30, 0x01	; 1
 26e:	62 e0       	ldi	r22, 0x02	; 2
 270:	60 83       	st	Z, r22
 272:	31 97       	sbiw	r30, 0x01	; 1
 274:	63 e0       	ldi	r22, 0x03	; 3
 276:	60 83       	st	Z, r22
 278:	31 97       	sbiw	r30, 0x01	; 1
 27a:	64 e0       	ldi	r22, 0x04	; 4
 27c:	60 83       	st	Z, r22
 27e:	31 97       	sbiw	r30, 0x01	; 1
 280:	65 e0       	ldi	r22, 0x05	; 5
 282:	60 83       	st	Z, r22
 284:	31 97       	sbiw	r30, 0x01	; 1
 286:	66 e0       	ldi	r22, 0x06	; 6
 288:	60 83       	st	Z, r22
 28a:	31 97       	sbiw	r30, 0x01	; 1
 28c:	67 e0       	ldi	r22, 0x07	; 7
 28e:	60 83       	st	Z, r22
 290:	31 97       	sbiw	r30, 0x01	; 1
 292:	68 e0       	ldi	r22, 0x08	; 8
 294:	60 83       	st	Z, r22
 296:	31 97       	sbiw	r30, 0x01	; 1
 298:	69 e0       	ldi	r22, 0x09	; 9
 29a:	60 83       	st	Z, r22
 29c:	31 97       	sbiw	r30, 0x01	; 1
 29e:	60 e1       	ldi	r22, 0x10	; 16
 2a0:	60 83       	st	Z, r22
 2a2:	31 97       	sbiw	r30, 0x01	; 1
 2a4:	30 83       	st	Z, r19
 2a6:	31 97       	sbiw	r30, 0x01	; 1
 2a8:	32 e1       	ldi	r19, 0x12	; 18
 2aa:	30 83       	st	Z, r19
 2ac:	31 97       	sbiw	r30, 0x01	; 1
 2ae:	33 e1       	ldi	r19, 0x13	; 19
 2b0:	30 83       	st	Z, r19
 2b2:	31 97       	sbiw	r30, 0x01	; 1
 2b4:	34 e1       	ldi	r19, 0x14	; 20
 2b6:	30 83       	st	Z, r19
 2b8:	31 97       	sbiw	r30, 0x01	; 1
 2ba:	35 e1       	ldi	r19, 0x15	; 21
 2bc:	30 83       	st	Z, r19
 2be:	31 97       	sbiw	r30, 0x01	; 1
 2c0:	36 e1       	ldi	r19, 0x16	; 22
 2c2:	30 83       	st	Z, r19
 2c4:	31 97       	sbiw	r30, 0x01	; 1
 2c6:	37 e1       	ldi	r19, 0x17	; 23
 2c8:	30 83       	st	Z, r19
 2ca:	31 97       	sbiw	r30, 0x01	; 1
 2cc:	38 e1       	ldi	r19, 0x18	; 24
 2ce:	30 83       	st	Z, r19
 2d0:	31 97       	sbiw	r30, 0x01	; 1
 2d2:	39 e1       	ldi	r19, 0x19	; 25
 2d4:	30 83       	st	Z, r19
 2d6:	31 97       	sbiw	r30, 0x01	; 1
 2d8:	30 e2       	ldi	r19, 0x20	; 32
 2da:	30 83       	st	Z, r19
 2dc:	31 97       	sbiw	r30, 0x01	; 1
 2de:	31 e2       	ldi	r19, 0x21	; 33
 2e0:	30 83       	st	Z, r19
 2e2:	31 97       	sbiw	r30, 0x01	; 1
 2e4:	20 83       	st	Z, r18
 2e6:	31 97       	sbiw	r30, 0x01	; 1
 2e8:	23 e2       	ldi	r18, 0x23	; 35
 2ea:	20 83       	st	Z, r18
 2ec:	31 97       	sbiw	r30, 0x01	; 1
 2ee:	40 83       	st	Z, r20
 2f0:	31 97       	sbiw	r30, 0x01	; 1
 2f2:	50 83       	st	Z, r21
 2f4:	31 97       	sbiw	r30, 0x01	; 1
 2f6:	26 e2       	ldi	r18, 0x26	; 38
 2f8:	20 83       	st	Z, r18
 2fa:	31 97       	sbiw	r30, 0x01	; 1
 2fc:	27 e2       	ldi	r18, 0x27	; 39
 2fe:	20 83       	st	Z, r18
 300:	31 97       	sbiw	r30, 0x01	; 1
 302:	28 e2       	ldi	r18, 0x28	; 40
 304:	20 83       	st	Z, r18
 306:	31 97       	sbiw	r30, 0x01	; 1
 308:	29 e2       	ldi	r18, 0x29	; 41
 30a:	20 83       	st	Z, r18
 30c:	31 97       	sbiw	r30, 0x01	; 1
 30e:	20 e3       	ldi	r18, 0x30	; 48
 310:	20 83       	st	Z, r18
 312:	31 97       	sbiw	r30, 0x01	; 1
 314:	21 e3       	ldi	r18, 0x31	; 49
 316:	20 83       	st	Z, r18
 318:	86 97       	sbiw	r24, 0x26	; 38
 31a:	08 95       	ret

0000031c <xPortStartScheduler>:
 31c:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x7f8089>
 320:	8c e7       	ldi	r24, 0x7C	; 124
 322:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7f8088>
 326:	8b e0       	ldi	r24, 0x0B	; 11
 328:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7f8081>
 32c:	ef e6       	ldi	r30, 0x6F	; 111
 32e:	f0 e0       	ldi	r31, 0x00	; 0
 330:	80 81       	ld	r24, Z
 332:	82 60       	ori	r24, 0x02	; 2
 334:	80 83       	st	Z, r24
 336:	a0 91 50 07 	lds	r26, 0x0750	; 0x800750 <pxCurrentTCB>
 33a:	b0 91 51 07 	lds	r27, 0x0751	; 0x800751 <pxCurrentTCB+0x1>
 33e:	cd 91       	ld	r28, X+
 340:	cd bf       	out	0x3d, r28	; 61
 342:	dd 91       	ld	r29, X+
 344:	de bf       	out	0x3e, r29	; 62
 346:	ff 91       	pop	r31
 348:	ef 91       	pop	r30
 34a:	df 91       	pop	r29
 34c:	cf 91       	pop	r28
 34e:	bf 91       	pop	r27
 350:	af 91       	pop	r26
 352:	9f 91       	pop	r25
 354:	8f 91       	pop	r24
 356:	7f 91       	pop	r23
 358:	6f 91       	pop	r22
 35a:	5f 91       	pop	r21
 35c:	4f 91       	pop	r20
 35e:	3f 91       	pop	r19
 360:	2f 91       	pop	r18
 362:	1f 91       	pop	r17
 364:	0f 91       	pop	r16
 366:	ff 90       	pop	r15
 368:	ef 90       	pop	r14
 36a:	df 90       	pop	r13
 36c:	cf 90       	pop	r12
 36e:	bf 90       	pop	r11
 370:	af 90       	pop	r10
 372:	9f 90       	pop	r9
 374:	8f 90       	pop	r8
 376:	7f 90       	pop	r7
 378:	6f 90       	pop	r6
 37a:	5f 90       	pop	r5
 37c:	4f 90       	pop	r4
 37e:	3f 90       	pop	r3
 380:	2f 90       	pop	r2
 382:	1f 90       	pop	r1
 384:	0f 90       	pop	r0
 386:	0f be       	out	0x3f, r0	; 63
 388:	0f 90       	pop	r0
 38a:	08 95       	ret
 38c:	81 e0       	ldi	r24, 0x01	; 1
 38e:	08 95       	ret

00000390 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
 390:	0f 92       	push	r0
 392:	0f b6       	in	r0, 0x3f	; 63
 394:	f8 94       	cli
 396:	0f 92       	push	r0
 398:	1f 92       	push	r1
 39a:	11 24       	eor	r1, r1
 39c:	2f 92       	push	r2
 39e:	3f 92       	push	r3
 3a0:	4f 92       	push	r4
 3a2:	5f 92       	push	r5
 3a4:	6f 92       	push	r6
 3a6:	7f 92       	push	r7
 3a8:	8f 92       	push	r8
 3aa:	9f 92       	push	r9
 3ac:	af 92       	push	r10
 3ae:	bf 92       	push	r11
 3b0:	cf 92       	push	r12
 3b2:	df 92       	push	r13
 3b4:	ef 92       	push	r14
 3b6:	ff 92       	push	r15
 3b8:	0f 93       	push	r16
 3ba:	1f 93       	push	r17
 3bc:	2f 93       	push	r18
 3be:	3f 93       	push	r19
 3c0:	4f 93       	push	r20
 3c2:	5f 93       	push	r21
 3c4:	6f 93       	push	r22
 3c6:	7f 93       	push	r23
 3c8:	8f 93       	push	r24
 3ca:	9f 93       	push	r25
 3cc:	af 93       	push	r26
 3ce:	bf 93       	push	r27
 3d0:	cf 93       	push	r28
 3d2:	df 93       	push	r29
 3d4:	ef 93       	push	r30
 3d6:	ff 93       	push	r31
 3d8:	a0 91 50 07 	lds	r26, 0x0750	; 0x800750 <pxCurrentTCB>
 3dc:	b0 91 51 07 	lds	r27, 0x0751	; 0x800751 <pxCurrentTCB+0x1>
 3e0:	0d b6       	in	r0, 0x3d	; 61
 3e2:	0d 92       	st	X+, r0
 3e4:	0e b6       	in	r0, 0x3e	; 62
 3e6:	0d 92       	st	X+, r0
	vTaskSwitchContext();
 3e8:	83 d4       	rcall	.+2310   	; 0xcf0 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
 3ea:	a0 91 50 07 	lds	r26, 0x0750	; 0x800750 <pxCurrentTCB>
 3ee:	b0 91 51 07 	lds	r27, 0x0751	; 0x800751 <pxCurrentTCB+0x1>
 3f2:	cd 91       	ld	r28, X+
 3f4:	cd bf       	out	0x3d, r28	; 61
 3f6:	dd 91       	ld	r29, X+
 3f8:	de bf       	out	0x3e, r29	; 62
 3fa:	ff 91       	pop	r31
 3fc:	ef 91       	pop	r30
 3fe:	df 91       	pop	r29
 400:	cf 91       	pop	r28
 402:	bf 91       	pop	r27
 404:	af 91       	pop	r26
 406:	9f 91       	pop	r25
 408:	8f 91       	pop	r24
 40a:	7f 91       	pop	r23
 40c:	6f 91       	pop	r22
 40e:	5f 91       	pop	r21
 410:	4f 91       	pop	r20
 412:	3f 91       	pop	r19
 414:	2f 91       	pop	r18
 416:	1f 91       	pop	r17
 418:	0f 91       	pop	r16
 41a:	ff 90       	pop	r15
 41c:	ef 90       	pop	r14
 41e:	df 90       	pop	r13
 420:	cf 90       	pop	r12
 422:	bf 90       	pop	r11
 424:	af 90       	pop	r10
 426:	9f 90       	pop	r9
 428:	8f 90       	pop	r8
 42a:	7f 90       	pop	r7
 42c:	6f 90       	pop	r6
 42e:	5f 90       	pop	r5
 430:	4f 90       	pop	r4
 432:	3f 90       	pop	r3
 434:	2f 90       	pop	r2
 436:	1f 90       	pop	r1
 438:	0f 90       	pop	r0
 43a:	0f be       	out	0x3f, r0	; 63
 43c:	0f 90       	pop	r0

	asm volatile ( "ret" );
 43e:	08 95       	ret

00000440 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
 440:	0f 92       	push	r0
 442:	0f b6       	in	r0, 0x3f	; 63
 444:	f8 94       	cli
 446:	0f 92       	push	r0
 448:	1f 92       	push	r1
 44a:	11 24       	eor	r1, r1
 44c:	2f 92       	push	r2
 44e:	3f 92       	push	r3
 450:	4f 92       	push	r4
 452:	5f 92       	push	r5
 454:	6f 92       	push	r6
 456:	7f 92       	push	r7
 458:	8f 92       	push	r8
 45a:	9f 92       	push	r9
 45c:	af 92       	push	r10
 45e:	bf 92       	push	r11
 460:	cf 92       	push	r12
 462:	df 92       	push	r13
 464:	ef 92       	push	r14
 466:	ff 92       	push	r15
 468:	0f 93       	push	r16
 46a:	1f 93       	push	r17
 46c:	2f 93       	push	r18
 46e:	3f 93       	push	r19
 470:	4f 93       	push	r20
 472:	5f 93       	push	r21
 474:	6f 93       	push	r22
 476:	7f 93       	push	r23
 478:	8f 93       	push	r24
 47a:	9f 93       	push	r25
 47c:	af 93       	push	r26
 47e:	bf 93       	push	r27
 480:	cf 93       	push	r28
 482:	df 93       	push	r29
 484:	ef 93       	push	r30
 486:	ff 93       	push	r31
 488:	a0 91 50 07 	lds	r26, 0x0750	; 0x800750 <pxCurrentTCB>
 48c:	b0 91 51 07 	lds	r27, 0x0751	; 0x800751 <pxCurrentTCB+0x1>
 490:	0d b6       	in	r0, 0x3d	; 61
 492:	0d 92       	st	X+, r0
 494:	0e b6       	in	r0, 0x3e	; 62
 496:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
 498:	81 d2       	rcall	.+1282   	; 0x99c <xTaskIncrementTick>
 49a:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
 49c:	29 d4       	rcall	.+2130   	; 0xcf0 <vTaskSwitchContext>
 49e:	a0 91 50 07 	lds	r26, 0x0750	; 0x800750 <pxCurrentTCB>
	}
	portRESTORE_CONTEXT();
 4a2:	b0 91 51 07 	lds	r27, 0x0751	; 0x800751 <pxCurrentTCB+0x1>
 4a6:	cd 91       	ld	r28, X+
 4a8:	cd bf       	out	0x3d, r28	; 61
 4aa:	dd 91       	ld	r29, X+
 4ac:	de bf       	out	0x3e, r29	; 62
 4ae:	ff 91       	pop	r31
 4b0:	ef 91       	pop	r30
 4b2:	df 91       	pop	r29
 4b4:	cf 91       	pop	r28
 4b6:	bf 91       	pop	r27
 4b8:	af 91       	pop	r26
 4ba:	9f 91       	pop	r25
 4bc:	8f 91       	pop	r24
 4be:	7f 91       	pop	r23
 4c0:	6f 91       	pop	r22
 4c2:	5f 91       	pop	r21
 4c4:	4f 91       	pop	r20
 4c6:	3f 91       	pop	r19
 4c8:	2f 91       	pop	r18
 4ca:	1f 91       	pop	r17
 4cc:	0f 91       	pop	r16
 4ce:	ff 90       	pop	r15
 4d0:	ef 90       	pop	r14
 4d2:	df 90       	pop	r13
 4d4:	cf 90       	pop	r12
 4d6:	bf 90       	pop	r11
 4d8:	af 90       	pop	r10
 4da:	9f 90       	pop	r9
 4dc:	8f 90       	pop	r8
 4de:	7f 90       	pop	r7
 4e0:	6f 90       	pop	r6
 4e2:	5f 90       	pop	r5
 4e4:	4f 90       	pop	r4
 4e6:	3f 90       	pop	r3
 4e8:	2f 90       	pop	r2
 4ea:	1f 90       	pop	r1
 4ec:	0f 90       	pop	r0
 4ee:	0f be       	out	0x3f, r0	; 63
 4f0:	0f 90       	pop	r0
 4f2:	08 95       	ret

000004f4 <__vector_11>:

	asm volatile ( "ret" );
 4f4:	a5 df       	rcall	.-182    	; 0x440 <vPortYieldFromTick>
	 */
	void TIMER1_COMPA_vect(void) __attribute__ ((signal, naked));
	void TIMER1_COMPA_vect(void)
	{
		vPortYieldFromTick();
		asm volatile ( "reti" );
 4f6:	18 95       	reti

000004f8 <pvPortMalloc>:
	pxIterator->pxNextFreeBlock = pxBlockToInsert;									\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
 4f8:	0f 93       	push	r16
 4fa:	1f 93       	push	r17
 4fc:	cf 93       	push	r28
 4fe:	df 93       	push	r29
 500:	ec 01       	movw	r28, r24
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
 502:	3c d2       	rcall	.+1144   	; 0x97c <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
 504:	80 91 14 01 	lds	r24, 0x0114	; 0x800114 <__data_end>
 508:	81 11       	cpse	r24, r1
 50a:	1d c0       	rjmp	.+58     	; 0x546 <pvPortMalloc+0x4e>
	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 50c:	e9 e1       	ldi	r30, 0x19	; 25
 50e:	f1 e0       	ldi	r31, 0x01	; 1
 510:	8e e1       	ldi	r24, 0x1E	; 30
 512:	91 e0       	ldi	r25, 0x01	; 1
 514:	91 83       	std	Z+1, r25	; 0x01
 516:	80 83       	st	Z, r24
	xStart.xBlockSize = ( size_t ) 0;
 518:	13 82       	std	Z+3, r1	; 0x03
 51a:	12 82       	std	Z+2, r1	; 0x02

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
 51c:	e5 e1       	ldi	r30, 0x15	; 21
 51e:	f1 e0       	ldi	r31, 0x01	; 1
 520:	8b ed       	ldi	r24, 0xDB	; 219
 522:	95 e0       	ldi	r25, 0x05	; 5
 524:	93 83       	std	Z+3, r25	; 0x03
 526:	82 83       	std	Z+2, r24	; 0x02
	xEnd.pxNextFreeBlock = NULL;
 528:	11 82       	std	Z+1, r1	; 0x01
 52a:	10 82       	st	Z, r1

	/* To start with there is a single free block that is sized to take up the
	entire heap space. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;
 52c:	ad e1       	ldi	r26, 0x1D	; 29
 52e:	b1 e0       	ldi	r27, 0x01	; 1
 530:	14 96       	adiw	r26, 0x04	; 4
 532:	9c 93       	st	X, r25
 534:	8e 93       	st	-X, r24
 536:	13 97       	sbiw	r26, 0x03	; 3
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
 538:	12 96       	adiw	r26, 0x02	; 2
 53a:	fc 93       	st	X, r31
 53c:	ee 93       	st	-X, r30
 53e:	11 97       	sbiw	r26, 0x01	; 1
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
		{
			prvHeapInit();
			xHeapHasBeenInitialised = pdTRUE;
 540:	81 e0       	ldi	r24, 0x01	; 1
 542:	80 93 14 01 	sts	0x0114, r24	; 0x800114 <__data_end>
		}

		/* The wanted size is increased so it can contain a BlockLink_t
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
 546:	20 97       	sbiw	r28, 0x00	; 0
 548:	09 f4       	brne	.+2      	; 0x54c <pvPortMalloc+0x54>
 54a:	5f c0       	rjmp	.+190    	; 0x60a <pvPortMalloc+0x112>
		{
			xWantedSize += heapSTRUCT_SIZE;
 54c:	9e 01       	movw	r18, r28
 54e:	2c 5f       	subi	r18, 0xFC	; 252
 550:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
 552:	23 96       	adiw	r28, 0x03	; 3
 554:	ca 3d       	cpi	r28, 0xDA	; 218
 556:	d5 40       	sbci	r29, 0x05	; 5
 558:	08 f0       	brcs	.+2      	; 0x55c <pvPortMalloc+0x64>
 55a:	5a c0       	rjmp	.+180    	; 0x610 <pvPortMalloc+0x118>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
 55c:	e0 91 19 01 	lds	r30, 0x0119	; 0x800119 <xStart>
 560:	f0 91 1a 01 	lds	r31, 0x011A	; 0x80011a <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
 564:	a9 e1       	ldi	r26, 0x19	; 25
 566:	b1 e0       	ldi	r27, 0x01	; 1
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 568:	02 c0       	rjmp	.+4      	; 0x56e <pvPortMalloc+0x76>
 56a:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
 56c:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 56e:	82 81       	ldd	r24, Z+2	; 0x02
 570:	93 81       	ldd	r25, Z+3	; 0x03
 572:	82 17       	cp	r24, r18
 574:	93 07       	cpc	r25, r19
 576:	20 f4       	brcc	.+8      	; 0x580 <pvPortMalloc+0x88>
 578:	80 81       	ld	r24, Z
 57a:	91 81       	ldd	r25, Z+1	; 0x01
 57c:	00 97       	sbiw	r24, 0x00	; 0
 57e:	a9 f7       	brne	.-22     	; 0x56a <pvPortMalloc+0x72>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
 580:	c1 e0       	ldi	r28, 0x01	; 1
 582:	e5 31       	cpi	r30, 0x15	; 21
 584:	fc 07       	cpc	r31, r28
 586:	09 f4       	brne	.+2      	; 0x58a <pvPortMalloc+0x92>
 588:	46 c0       	rjmp	.+140    	; 0x616 <pvPortMalloc+0x11e>
			{
				/* Return the memory space - jumping over the BlockLink_t structure
				at its start. */
				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
 58a:	cd 91       	ld	r28, X+
 58c:	dc 91       	ld	r29, X
 58e:	11 97       	sbiw	r26, 0x01	; 1
 590:	8e 01       	movw	r16, r28
 592:	0c 5f       	subi	r16, 0xFC	; 252
 594:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken out of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 596:	80 81       	ld	r24, Z
 598:	91 81       	ldd	r25, Z+1	; 0x01
 59a:	8d 93       	st	X+, r24
 59c:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 59e:	82 81       	ldd	r24, Z+2	; 0x02
 5a0:	93 81       	ldd	r25, Z+3	; 0x03
 5a2:	82 1b       	sub	r24, r18
 5a4:	93 0b       	sbc	r25, r19
 5a6:	89 30       	cpi	r24, 0x09	; 9
 5a8:	91 05       	cpc	r25, r1
 5aa:	10 f1       	brcs	.+68     	; 0x5f0 <pvPortMalloc+0xf8>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
 5ac:	bf 01       	movw	r22, r30
 5ae:	62 0f       	add	r22, r18
 5b0:	73 1f       	adc	r23, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 5b2:	db 01       	movw	r26, r22
 5b4:	13 96       	adiw	r26, 0x03	; 3
 5b6:	9c 93       	st	X, r25
 5b8:	8e 93       	st	-X, r24
 5ba:	12 97       	sbiw	r26, 0x02	; 2
					pxBlock->xBlockSize = xWantedSize;
 5bc:	33 83       	std	Z+3, r19	; 0x03
 5be:	22 83       	std	Z+2, r18	; 0x02

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
 5c0:	12 96       	adiw	r26, 0x02	; 2
 5c2:	4d 91       	ld	r20, X+
 5c4:	5c 91       	ld	r21, X
 5c6:	13 97       	sbiw	r26, 0x03	; 3
 5c8:	89 e1       	ldi	r24, 0x19	; 25
 5ca:	91 e0       	ldi	r25, 0x01	; 1
 5cc:	01 c0       	rjmp	.+2      	; 0x5d0 <pvPortMalloc+0xd8>
 5ce:	cd 01       	movw	r24, r26
 5d0:	ec 01       	movw	r28, r24
 5d2:	a8 81       	ld	r26, Y
 5d4:	b9 81       	ldd	r27, Y+1	; 0x01
 5d6:	12 96       	adiw	r26, 0x02	; 2
 5d8:	2d 91       	ld	r18, X+
 5da:	3c 91       	ld	r19, X
 5dc:	13 97       	sbiw	r26, 0x03	; 3
 5de:	24 17       	cp	r18, r20
 5e0:	35 07       	cpc	r19, r21
 5e2:	a8 f3       	brcs	.-22     	; 0x5ce <pvPortMalloc+0xd6>
 5e4:	eb 01       	movw	r28, r22
 5e6:	b9 83       	std	Y+1, r27	; 0x01
 5e8:	a8 83       	st	Y, r26
 5ea:	dc 01       	movw	r26, r24
 5ec:	6d 93       	st	X+, r22
 5ee:	7c 93       	st	X, r23
				}

				xFreeBytesRemaining -= pxBlock->xBlockSize;
 5f0:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
 5f4:	90 91 01 01 	lds	r25, 0x0101	; 0x800101 <__DATA_REGION_ORIGIN__+0x1>
 5f8:	22 81       	ldd	r18, Z+2	; 0x02
 5fa:	33 81       	ldd	r19, Z+3	; 0x03
 5fc:	82 1b       	sub	r24, r18
 5fe:	93 0b       	sbc	r25, r19
 600:	90 93 01 01 	sts	0x0101, r25	; 0x800101 <__DATA_REGION_ORIGIN__+0x1>
 604:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__DATA_REGION_ORIGIN__>
 608:	08 c0       	rjmp	.+16     	; 0x61a <pvPortMalloc+0x122>

void *pvPortMalloc( size_t xWantedSize )
{
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
 60a:	00 e0       	ldi	r16, 0x00	; 0
 60c:	10 e0       	ldi	r17, 0x00	; 0
 60e:	05 c0       	rjmp	.+10     	; 0x61a <pvPortMalloc+0x122>
 610:	00 e0       	ldi	r16, 0x00	; 0
 612:	10 e0       	ldi	r17, 0x00	; 0
 614:	02 c0       	rjmp	.+4      	; 0x61a <pvPortMalloc+0x122>
 616:	00 e0       	ldi	r16, 0x00	; 0
			}
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
 618:	10 e0       	ldi	r17, 0x00	; 0
 61a:	79 d2       	rcall	.+1266   	; 0xb0e <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
 61c:	c8 01       	movw	r24, r16
 61e:	df 91       	pop	r29
 620:	cf 91       	pop	r28
 622:	1f 91       	pop	r17
 624:	0f 91       	pop	r16
 626:	08 95       	ret

00000628 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
 628:	0f 93       	push	r16
 62a:	1f 93       	push	r17
 62c:	cf 93       	push	r28
 62e:	df 93       	push	r29
uint8_t *puc = ( uint8_t * ) pv;
BlockLink_t *pxLink;

	if( pv != NULL )
 630:	00 97       	sbiw	r24, 0x00	; 0
 632:	31 f1       	breq	.+76     	; 0x680 <vPortFree+0x58>
 634:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
 636:	8c 01       	movw	r16, r24
 638:	04 50       	subi	r16, 0x04	; 4
 63a:	11 09       	sbc	r17, r1

		/* This unexpected casting is to keep some compilers from issuing
		byte alignment warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
 63c:	9f d1       	rcall	.+830    	; 0x97c <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 63e:	f8 01       	movw	r30, r16
 640:	42 81       	ldd	r20, Z+2	; 0x02
 642:	53 81       	ldd	r21, Z+3	; 0x03
 644:	a9 e1       	ldi	r26, 0x19	; 25
 646:	b1 e0       	ldi	r27, 0x01	; 1
 648:	01 c0       	rjmp	.+2      	; 0x64c <vPortFree+0x24>
 64a:	df 01       	movw	r26, r30
 64c:	ed 91       	ld	r30, X+
 64e:	fc 91       	ld	r31, X
 650:	11 97       	sbiw	r26, 0x01	; 1
 652:	22 81       	ldd	r18, Z+2	; 0x02
 654:	33 81       	ldd	r19, Z+3	; 0x03
 656:	24 17       	cp	r18, r20
 658:	35 07       	cpc	r19, r21
 65a:	b8 f3       	brcs	.-18     	; 0x64a <vPortFree+0x22>
 65c:	24 97       	sbiw	r28, 0x04	; 4
 65e:	f9 83       	std	Y+1, r31	; 0x01
 660:	e8 83       	st	Y, r30
 662:	0d 93       	st	X+, r16
 664:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
 666:	20 91 00 01 	lds	r18, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
 66a:	30 91 01 01 	lds	r19, 0x0101	; 0x800101 <__DATA_REGION_ORIGIN__+0x1>
 66e:	8a 81       	ldd	r24, Y+2	; 0x02
 670:	9b 81       	ldd	r25, Y+3	; 0x03
 672:	82 0f       	add	r24, r18
 674:	93 1f       	adc	r25, r19
 676:	90 93 01 01 	sts	0x0101, r25	; 0x800101 <__DATA_REGION_ORIGIN__+0x1>
 67a:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__DATA_REGION_ORIGIN__>
			traceFREE( pv, pxLink->xBlockSize );
		}
		( void ) xTaskResumeAll();
 67e:	47 d2       	rcall	.+1166   	; 0xb0e <xTaskResumeAll>
	}
}
 680:	df 91       	pop	r29
 682:	cf 91       	pop	r28
 684:	1f 91       	pop	r17
 686:	0f 91       	pop	r16
 688:	08 95       	ret

0000068a <prvResetNextTaskUnblockTime>:
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 68a:	e0 91 18 07 	lds	r30, 0x0718	; 0x800718 <pxDelayedTaskList>
 68e:	f0 91 19 07 	lds	r31, 0x0719	; 0x800719 <pxDelayedTaskList+0x1>
 692:	80 81       	ld	r24, Z
 694:	81 11       	cpse	r24, r1
 696:	07 c0       	rjmp	.+14     	; 0x6a6 <prvResetNextTaskUnblockTime+0x1c>
 698:	8f ef       	ldi	r24, 0xFF	; 255
 69a:	9f ef       	ldi	r25, 0xFF	; 255
 69c:	90 93 03 01 	sts	0x0103, r25	; 0x800103 <xNextTaskUnblockTime+0x1>
 6a0:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <xNextTaskUnblockTime>
 6a4:	08 95       	ret
 6a6:	e0 91 18 07 	lds	r30, 0x0718	; 0x800718 <pxDelayedTaskList>
 6aa:	f0 91 19 07 	lds	r31, 0x0719	; 0x800719 <pxDelayedTaskList+0x1>
 6ae:	05 80       	ldd	r0, Z+5	; 0x05
 6b0:	f6 81       	ldd	r31, Z+6	; 0x06
 6b2:	e0 2d       	mov	r30, r0
 6b4:	06 80       	ldd	r0, Z+6	; 0x06
 6b6:	f7 81       	ldd	r31, Z+7	; 0x07
 6b8:	e0 2d       	mov	r30, r0
 6ba:	82 81       	ldd	r24, Z+2	; 0x02
 6bc:	93 81       	ldd	r25, Z+3	; 0x03
 6be:	90 93 03 01 	sts	0x0103, r25	; 0x800103 <xNextTaskUnblockTime+0x1>
 6c2:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <xNextTaskUnblockTime>
 6c6:	08 95       	ret

000006c8 <prvAddCurrentTaskToDelayedList>:
 6c8:	cf 93       	push	r28
 6ca:	df 93       	push	r29
 6cc:	ec 01       	movw	r28, r24
 6ce:	e0 91 50 07 	lds	r30, 0x0750	; 0x800750 <pxCurrentTCB>
 6d2:	f0 91 51 07 	lds	r31, 0x0751	; 0x800751 <pxCurrentTCB+0x1>
 6d6:	93 83       	std	Z+3, r25	; 0x03
 6d8:	82 83       	std	Z+2, r24	; 0x02
 6da:	80 91 00 07 	lds	r24, 0x0700	; 0x800700 <xTickCount>
 6de:	90 91 01 07 	lds	r25, 0x0701	; 0x800701 <xTickCount+0x1>
 6e2:	c8 17       	cp	r28, r24
 6e4:	d9 07       	cpc	r29, r25
 6e6:	60 f4       	brcc	.+24     	; 0x700 <prvAddCurrentTaskToDelayedList+0x38>
 6e8:	60 91 50 07 	lds	r22, 0x0750	; 0x800750 <pxCurrentTCB>
 6ec:	70 91 51 07 	lds	r23, 0x0751	; 0x800751 <pxCurrentTCB+0x1>
 6f0:	80 91 16 07 	lds	r24, 0x0716	; 0x800716 <pxOverflowDelayedTaskList>
 6f4:	90 91 17 07 	lds	r25, 0x0717	; 0x800717 <pxOverflowDelayedTaskList+0x1>
 6f8:	6e 5f       	subi	r22, 0xFE	; 254
 6fa:	7f 4f       	sbci	r23, 0xFF	; 255
 6fc:	4c dd       	rcall	.-1384   	; 0x196 <vListInsert>
 6fe:	16 c0       	rjmp	.+44     	; 0x72c <prvAddCurrentTaskToDelayedList+0x64>
 700:	60 91 50 07 	lds	r22, 0x0750	; 0x800750 <pxCurrentTCB>
 704:	70 91 51 07 	lds	r23, 0x0751	; 0x800751 <pxCurrentTCB+0x1>
 708:	80 91 18 07 	lds	r24, 0x0718	; 0x800718 <pxDelayedTaskList>
 70c:	90 91 19 07 	lds	r25, 0x0719	; 0x800719 <pxDelayedTaskList+0x1>
 710:	6e 5f       	subi	r22, 0xFE	; 254
 712:	7f 4f       	sbci	r23, 0xFF	; 255
 714:	40 dd       	rcall	.-1408   	; 0x196 <vListInsert>
 716:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <xNextTaskUnblockTime>
 71a:	90 91 03 01 	lds	r25, 0x0103	; 0x800103 <xNextTaskUnblockTime+0x1>
 71e:	c8 17       	cp	r28, r24
 720:	d9 07       	cpc	r29, r25
 722:	20 f4       	brcc	.+8      	; 0x72c <prvAddCurrentTaskToDelayedList+0x64>
 724:	d0 93 03 01 	sts	0x0103, r29	; 0x800103 <xNextTaskUnblockTime+0x1>
 728:	c0 93 02 01 	sts	0x0102, r28	; 0x800102 <xNextTaskUnblockTime>
 72c:	df 91       	pop	r29
 72e:	cf 91       	pop	r28
 730:	08 95       	ret

00000732 <xTaskGenericCreate>:
 732:	4f 92       	push	r4
 734:	5f 92       	push	r5
 736:	6f 92       	push	r6
 738:	7f 92       	push	r7
 73a:	8f 92       	push	r8
 73c:	9f 92       	push	r9
 73e:	af 92       	push	r10
 740:	bf 92       	push	r11
 742:	cf 92       	push	r12
 744:	df 92       	push	r13
 746:	ef 92       	push	r14
 748:	ff 92       	push	r15
 74a:	0f 93       	push	r16
 74c:	1f 93       	push	r17
 74e:	cf 93       	push	r28
 750:	df 93       	push	r29
 752:	4c 01       	movw	r8, r24
 754:	eb 01       	movw	r28, r22
 756:	5a 01       	movw	r10, r20
 758:	29 01       	movw	r4, r18
 75a:	c1 14       	cp	r12, r1
 75c:	d1 04       	cpc	r13, r1
 75e:	31 f4       	brne	.+12     	; 0x76c <xTaskGenericCreate+0x3a>
 760:	ca 01       	movw	r24, r20
 762:	ca de       	rcall	.-620    	; 0x4f8 <pvPortMalloc>
 764:	6c 01       	movw	r12, r24
 766:	89 2b       	or	r24, r25
 768:	09 f4       	brne	.+2      	; 0x76c <xTaskGenericCreate+0x3a>
 76a:	cd c0       	rjmp	.+410    	; 0x906 <__stack+0x7>
 76c:	86 e2       	ldi	r24, 0x26	; 38
 76e:	90 e0       	ldi	r25, 0x00	; 0
 770:	c3 de       	rcall	.-634    	; 0x4f8 <pvPortMalloc>
 772:	3c 01       	movw	r6, r24
 774:	00 97       	sbiw	r24, 0x00	; 0
 776:	79 f0       	breq	.+30     	; 0x796 <xTaskGenericCreate+0x64>
 778:	fc 01       	movw	r30, r24
 77a:	d0 8e       	std	Z+24, r13	; 0x18
 77c:	c7 8a       	std	Z+23, r12	; 0x17
 77e:	f1 e0       	ldi	r31, 0x01	; 1
 780:	af 1a       	sub	r10, r31
 782:	b1 08       	sbc	r11, r1
 784:	ca 0c       	add	r12, r10
 786:	db 1c       	adc	r13, r11
 788:	88 81       	ld	r24, Y
 78a:	f3 01       	movw	r30, r6
 78c:	81 8f       	std	Z+25, r24	; 0x19
 78e:	88 81       	ld	r24, Y
 790:	81 11       	cpse	r24, r1
 792:	04 c0       	rjmp	.+8      	; 0x79c <xTaskGenericCreate+0x6a>
 794:	13 c0       	rjmp	.+38     	; 0x7bc <xTaskGenericCreate+0x8a>
 796:	c6 01       	movw	r24, r12
 798:	47 df       	rcall	.-370    	; 0x628 <vPortFree>
 79a:	b5 c0       	rjmp	.+362    	; 0x906 <__stack+0x7>
 79c:	d3 01       	movw	r26, r6
 79e:	5a 96       	adiw	r26, 0x1a	; 26
 7a0:	fe 01       	movw	r30, r28
 7a2:	31 96       	adiw	r30, 0x01	; 1
 7a4:	9e 01       	movw	r18, r28
 7a6:	28 5f       	subi	r18, 0xF8	; 248
 7a8:	3f 4f       	sbci	r19, 0xFF	; 255
 7aa:	ef 01       	movw	r28, r30
 7ac:	81 91       	ld	r24, Z+
 7ae:	8d 93       	st	X+, r24
 7b0:	88 81       	ld	r24, Y
 7b2:	88 23       	and	r24, r24
 7b4:	19 f0       	breq	.+6      	; 0x7bc <xTaskGenericCreate+0x8a>
 7b6:	e2 17       	cp	r30, r18
 7b8:	f3 07       	cpc	r31, r19
 7ba:	b9 f7       	brne	.-18     	; 0x7aa <xTaskGenericCreate+0x78>
 7bc:	f3 01       	movw	r30, r6
 7be:	10 a2       	std	Z+32, r1	; 0x20
 7c0:	10 2f       	mov	r17, r16
 7c2:	04 30       	cpi	r16, 0x04	; 4
 7c4:	08 f0       	brcs	.+2      	; 0x7c8 <xTaskGenericCreate+0x96>
 7c6:	13 e0       	ldi	r17, 0x03	; 3
 7c8:	f3 01       	movw	r30, r6
 7ca:	16 8b       	std	Z+22, r17	; 0x16
 7cc:	e3 01       	movw	r28, r6
 7ce:	22 96       	adiw	r28, 0x02	; 2
 7d0:	ce 01       	movw	r24, r28
 7d2:	bc dc       	rcall	.-1672   	; 0x14c <vListInitialiseItem>
 7d4:	c3 01       	movw	r24, r6
 7d6:	0c 96       	adiw	r24, 0x0c	; 12
 7d8:	b9 dc       	rcall	.-1678   	; 0x14c <vListInitialiseItem>
 7da:	f3 01       	movw	r30, r6
 7dc:	71 86       	std	Z+9, r7	; 0x09
 7de:	60 86       	std	Z+8, r6	; 0x08
 7e0:	84 e0       	ldi	r24, 0x04	; 4
 7e2:	90 e0       	ldi	r25, 0x00	; 0
 7e4:	81 1b       	sub	r24, r17
 7e6:	91 09       	sbc	r25, r1
 7e8:	95 87       	std	Z+13, r25	; 0x0d
 7ea:	84 87       	std	Z+12, r24	; 0x0c
 7ec:	73 8a       	std	Z+19, r7	; 0x13
 7ee:	62 8a       	std	Z+18, r6	; 0x12
 7f0:	11 a2       	std	Z+33, r1	; 0x21
 7f2:	12 a2       	std	Z+34, r1	; 0x22
 7f4:	13 a2       	std	Z+35, r1	; 0x23
 7f6:	14 a2       	std	Z+36, r1	; 0x24
 7f8:	15 a2       	std	Z+37, r1	; 0x25
 7fa:	a2 01       	movw	r20, r4
 7fc:	b4 01       	movw	r22, r8
 7fe:	c6 01       	movw	r24, r12
 800:	21 dd       	rcall	.-1470   	; 0x244 <pxPortInitialiseStack>
 802:	f3 01       	movw	r30, r6
 804:	91 83       	std	Z+1, r25	; 0x01
 806:	80 83       	st	Z, r24
 808:	e1 14       	cp	r14, r1
 80a:	f1 04       	cpc	r15, r1
 80c:	19 f0       	breq	.+6      	; 0x814 <__DATA_REGION_LENGTH__+0x14>
 80e:	f7 01       	movw	r30, r14
 810:	71 82       	std	Z+1, r7	; 0x01
 812:	60 82       	st	Z, r6
 814:	0f b6       	in	r0, 0x3f	; 63
 816:	f8 94       	cli
 818:	0f 92       	push	r0
 81a:	80 91 02 07 	lds	r24, 0x0702	; 0x800702 <uxCurrentNumberOfTasks>
 81e:	8f 5f       	subi	r24, 0xFF	; 255
 820:	80 93 02 07 	sts	0x0702, r24	; 0x800702 <uxCurrentNumberOfTasks>
 824:	80 91 50 07 	lds	r24, 0x0750	; 0x800750 <pxCurrentTCB>
 828:	90 91 51 07 	lds	r25, 0x0751	; 0x800751 <pxCurrentTCB+0x1>
 82c:	89 2b       	or	r24, r25
 82e:	69 f5       	brne	.+90     	; 0x88a <__DATA_REGION_LENGTH__+0x8a>
 830:	70 92 51 07 	sts	0x0751, r7	; 0x800751 <pxCurrentTCB+0x1>
 834:	60 92 50 07 	sts	0x0750, r6	; 0x800750 <pxCurrentTCB>
 838:	80 91 02 07 	lds	r24, 0x0702	; 0x800702 <uxCurrentNumberOfTasks>
 83c:	81 30       	cpi	r24, 0x01	; 1
 83e:	a1 f5       	brne	.+104    	; 0x8a8 <__DATA_REGION_LENGTH__+0xa8>
 840:	8c e2       	ldi	r24, 0x2C	; 44
 842:	97 e0       	ldi	r25, 0x07	; 7
 844:	75 dc       	rcall	.-1814   	; 0x130 <vListInitialise>
 846:	85 e3       	ldi	r24, 0x35	; 53
 848:	97 e0       	ldi	r25, 0x07	; 7
 84a:	72 dc       	rcall	.-1820   	; 0x130 <vListInitialise>
 84c:	8e e3       	ldi	r24, 0x3E	; 62
 84e:	97 e0       	ldi	r25, 0x07	; 7
 850:	6f dc       	rcall	.-1826   	; 0x130 <vListInitialise>
 852:	87 e4       	ldi	r24, 0x47	; 71
 854:	97 e0       	ldi	r25, 0x07	; 7
 856:	6c dc       	rcall	.-1832   	; 0x130 <vListInitialise>
 858:	83 e2       	ldi	r24, 0x23	; 35
 85a:	97 e0       	ldi	r25, 0x07	; 7
 85c:	69 dc       	rcall	.-1838   	; 0x130 <vListInitialise>
 85e:	8a e1       	ldi	r24, 0x1A	; 26
 860:	97 e0       	ldi	r25, 0x07	; 7
 862:	66 dc       	rcall	.-1844   	; 0x130 <vListInitialise>
 864:	8d e0       	ldi	r24, 0x0D	; 13
 866:	97 e0       	ldi	r25, 0x07	; 7
 868:	63 dc       	rcall	.-1850   	; 0x130 <vListInitialise>
 86a:	84 e0       	ldi	r24, 0x04	; 4
 86c:	97 e0       	ldi	r25, 0x07	; 7
 86e:	60 dc       	rcall	.-1856   	; 0x130 <vListInitialise>
 870:	83 e2       	ldi	r24, 0x23	; 35
 872:	97 e0       	ldi	r25, 0x07	; 7
 874:	90 93 19 07 	sts	0x0719, r25	; 0x800719 <pxDelayedTaskList+0x1>
 878:	80 93 18 07 	sts	0x0718, r24	; 0x800718 <pxDelayedTaskList>
 87c:	8a e1       	ldi	r24, 0x1A	; 26
 87e:	97 e0       	ldi	r25, 0x07	; 7
 880:	90 93 17 07 	sts	0x0717, r25	; 0x800717 <pxOverflowDelayedTaskList+0x1>
 884:	80 93 16 07 	sts	0x0716, r24	; 0x800716 <pxOverflowDelayedTaskList>
 888:	0f c0       	rjmp	.+30     	; 0x8a8 <__DATA_REGION_LENGTH__+0xa8>
 88a:	80 91 fe 06 	lds	r24, 0x06FE	; 0x8006fe <xSchedulerRunning>
 88e:	81 11       	cpse	r24, r1
 890:	0b c0       	rjmp	.+22     	; 0x8a8 <__DATA_REGION_LENGTH__+0xa8>
 892:	e0 91 50 07 	lds	r30, 0x0750	; 0x800750 <pxCurrentTCB>
 896:	f0 91 51 07 	lds	r31, 0x0751	; 0x800751 <pxCurrentTCB+0x1>
 89a:	86 89       	ldd	r24, Z+22	; 0x16
 89c:	08 17       	cp	r16, r24
 89e:	20 f0       	brcs	.+8      	; 0x8a8 <__DATA_REGION_LENGTH__+0xa8>
 8a0:	70 92 51 07 	sts	0x0751, r7	; 0x800751 <pxCurrentTCB+0x1>
 8a4:	60 92 50 07 	sts	0x0750, r6	; 0x800750 <pxCurrentTCB>
 8a8:	80 91 fa 06 	lds	r24, 0x06FA	; 0x8006fa <uxTaskNumber>
 8ac:	8f 5f       	subi	r24, 0xFF	; 255
 8ae:	80 93 fa 06 	sts	0x06FA, r24	; 0x8006fa <uxTaskNumber>
 8b2:	f3 01       	movw	r30, r6
 8b4:	86 89       	ldd	r24, Z+22	; 0x16
 8b6:	90 91 ff 06 	lds	r25, 0x06FF	; 0x8006ff <uxTopReadyPriority>
 8ba:	98 17       	cp	r25, r24
 8bc:	10 f4       	brcc	.+4      	; 0x8c2 <__DATA_REGION_LENGTH__+0xc2>
 8be:	80 93 ff 06 	sts	0x06FF, r24	; 0x8006ff <uxTopReadyPriority>
 8c2:	90 e0       	ldi	r25, 0x00	; 0
 8c4:	9c 01       	movw	r18, r24
 8c6:	22 0f       	add	r18, r18
 8c8:	33 1f       	adc	r19, r19
 8ca:	22 0f       	add	r18, r18
 8cc:	33 1f       	adc	r19, r19
 8ce:	22 0f       	add	r18, r18
 8d0:	33 1f       	adc	r19, r19
 8d2:	82 0f       	add	r24, r18
 8d4:	93 1f       	adc	r25, r19
 8d6:	be 01       	movw	r22, r28
 8d8:	84 5d       	subi	r24, 0xD4	; 212
 8da:	98 4f       	sbci	r25, 0xF8	; 248
 8dc:	3b dc       	rcall	.-1930   	; 0x154 <vListInsertEnd>
 8de:	0f 90       	pop	r0
 8e0:	0f be       	out	0x3f, r0	; 63
 8e2:	80 91 fe 06 	lds	r24, 0x06FE	; 0x8006fe <xSchedulerRunning>
 8e6:	88 23       	and	r24, r24
 8e8:	51 f0       	breq	.+20     	; 0x8fe <__DATA_REGION_LENGTH__+0xfe>
 8ea:	e0 91 50 07 	lds	r30, 0x0750	; 0x800750 <pxCurrentTCB>
 8ee:	f0 91 51 07 	lds	r31, 0x0751	; 0x800751 <pxCurrentTCB+0x1>
 8f2:	86 89       	ldd	r24, Z+22	; 0x16
 8f4:	80 17       	cp	r24, r16
 8f6:	28 f4       	brcc	.+10     	; 0x902 <__stack+0x3>
 8f8:	4b dd       	rcall	.-1386   	; 0x390 <vPortYield>
 8fa:	81 e0       	ldi	r24, 0x01	; 1
 8fc:	05 c0       	rjmp	.+10     	; 0x908 <__stack+0x9>
 8fe:	81 e0       	ldi	r24, 0x01	; 1
 900:	03 c0       	rjmp	.+6      	; 0x908 <__stack+0x9>
 902:	81 e0       	ldi	r24, 0x01	; 1
 904:	01 c0       	rjmp	.+2      	; 0x908 <__stack+0x9>
 906:	8f ef       	ldi	r24, 0xFF	; 255
 908:	df 91       	pop	r29
 90a:	cf 91       	pop	r28
 90c:	1f 91       	pop	r17
 90e:	0f 91       	pop	r16
 910:	ff 90       	pop	r15
 912:	ef 90       	pop	r14
 914:	df 90       	pop	r13
 916:	cf 90       	pop	r12
 918:	bf 90       	pop	r11
 91a:	af 90       	pop	r10
 91c:	9f 90       	pop	r9
 91e:	8f 90       	pop	r8
 920:	7f 90       	pop	r7
 922:	6f 90       	pop	r6
 924:	5f 90       	pop	r5
 926:	4f 90       	pop	r4
 928:	08 95       	ret

0000092a <vTaskStartScheduler>:
 92a:	af 92       	push	r10
 92c:	bf 92       	push	r11
 92e:	cf 92       	push	r12
 930:	df 92       	push	r13
 932:	ef 92       	push	r14
 934:	ff 92       	push	r15
 936:	0f 93       	push	r16
 938:	a1 2c       	mov	r10, r1
 93a:	b1 2c       	mov	r11, r1
 93c:	c1 2c       	mov	r12, r1
 93e:	d1 2c       	mov	r13, r1
 940:	e1 2c       	mov	r14, r1
 942:	f1 2c       	mov	r15, r1
 944:	00 e0       	ldi	r16, 0x00	; 0
 946:	20 e0       	ldi	r18, 0x00	; 0
 948:	30 e0       	ldi	r19, 0x00	; 0
 94a:	45 e5       	ldi	r20, 0x55	; 85
 94c:	50 e0       	ldi	r21, 0x00	; 0
 94e:	6e e0       	ldi	r22, 0x0E	; 14
 950:	71 e0       	ldi	r23, 0x01	; 1
 952:	81 e4       	ldi	r24, 0x41	; 65
 954:	96 e0       	ldi	r25, 0x06	; 6
 956:	ed de       	rcall	.-550    	; 0x732 <xTaskGenericCreate>
 958:	81 30       	cpi	r24, 0x01	; 1
 95a:	41 f4       	brne	.+16     	; 0x96c <vTaskStartScheduler+0x42>
 95c:	f8 94       	cli
 95e:	80 93 fe 06 	sts	0x06FE, r24	; 0x8006fe <xSchedulerRunning>
 962:	10 92 01 07 	sts	0x0701, r1	; 0x800701 <xTickCount+0x1>
 966:	10 92 00 07 	sts	0x0700, r1	; 0x800700 <xTickCount>
 96a:	d8 dc       	rcall	.-1616   	; 0x31c <xPortStartScheduler>
 96c:	0f 91       	pop	r16
 96e:	ff 90       	pop	r15
 970:	ef 90       	pop	r14
 972:	df 90       	pop	r13
 974:	cf 90       	pop	r12
 976:	bf 90       	pop	r11
 978:	af 90       	pop	r10
 97a:	08 95       	ret

0000097c <vTaskSuspendAll>:
 97c:	80 91 f9 06 	lds	r24, 0x06F9	; 0x8006f9 <uxSchedulerSuspended>
 980:	8f 5f       	subi	r24, 0xFF	; 255
 982:	80 93 f9 06 	sts	0x06F9, r24	; 0x8006f9 <uxSchedulerSuspended>
 986:	08 95       	ret

00000988 <xTaskGetTickCount>:
 988:	0f b6       	in	r0, 0x3f	; 63
 98a:	f8 94       	cli
 98c:	0f 92       	push	r0
 98e:	80 91 00 07 	lds	r24, 0x0700	; 0x800700 <xTickCount>
 992:	90 91 01 07 	lds	r25, 0x0701	; 0x800701 <xTickCount+0x1>
 996:	0f 90       	pop	r0
 998:	0f be       	out	0x3f, r0	; 63
 99a:	08 95       	ret

0000099c <xTaskIncrementTick>:
 99c:	cf 92       	push	r12
 99e:	df 92       	push	r13
 9a0:	ef 92       	push	r14
 9a2:	ff 92       	push	r15
 9a4:	0f 93       	push	r16
 9a6:	1f 93       	push	r17
 9a8:	cf 93       	push	r28
 9aa:	df 93       	push	r29
 9ac:	80 91 f9 06 	lds	r24, 0x06F9	; 0x8006f9 <uxSchedulerSuspended>
 9b0:	81 11       	cpse	r24, r1
 9b2:	97 c0       	rjmp	.+302    	; 0xae2 <xTaskIncrementTick+0x146>
 9b4:	80 91 00 07 	lds	r24, 0x0700	; 0x800700 <xTickCount>
 9b8:	90 91 01 07 	lds	r25, 0x0701	; 0x800701 <xTickCount+0x1>
 9bc:	01 96       	adiw	r24, 0x01	; 1
 9be:	90 93 01 07 	sts	0x0701, r25	; 0x800701 <xTickCount+0x1>
 9c2:	80 93 00 07 	sts	0x0700, r24	; 0x800700 <xTickCount>
 9c6:	e0 90 00 07 	lds	r14, 0x0700	; 0x800700 <xTickCount>
 9ca:	f0 90 01 07 	lds	r15, 0x0701	; 0x800701 <xTickCount+0x1>
 9ce:	e1 14       	cp	r14, r1
 9d0:	f1 04       	cpc	r15, r1
 9d2:	b1 f4       	brne	.+44     	; 0xa00 <xTaskIncrementTick+0x64>
 9d4:	80 91 18 07 	lds	r24, 0x0718	; 0x800718 <pxDelayedTaskList>
 9d8:	90 91 19 07 	lds	r25, 0x0719	; 0x800719 <pxDelayedTaskList+0x1>
 9dc:	20 91 16 07 	lds	r18, 0x0716	; 0x800716 <pxOverflowDelayedTaskList>
 9e0:	30 91 17 07 	lds	r19, 0x0717	; 0x800717 <pxOverflowDelayedTaskList+0x1>
 9e4:	30 93 19 07 	sts	0x0719, r19	; 0x800719 <pxDelayedTaskList+0x1>
 9e8:	20 93 18 07 	sts	0x0718, r18	; 0x800718 <pxDelayedTaskList>
 9ec:	90 93 17 07 	sts	0x0717, r25	; 0x800717 <pxOverflowDelayedTaskList+0x1>
 9f0:	80 93 16 07 	sts	0x0716, r24	; 0x800716 <pxOverflowDelayedTaskList>
 9f4:	80 91 fb 06 	lds	r24, 0x06FB	; 0x8006fb <xNumOfOverflows>
 9f8:	8f 5f       	subi	r24, 0xFF	; 255
 9fa:	80 93 fb 06 	sts	0x06FB, r24	; 0x8006fb <xNumOfOverflows>
 9fe:	45 de       	rcall	.-886    	; 0x68a <prvResetNextTaskUnblockTime>
 a00:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <xNextTaskUnblockTime>
 a04:	90 91 03 01 	lds	r25, 0x0103	; 0x800103 <xNextTaskUnblockTime+0x1>
 a08:	e8 16       	cp	r14, r24
 a0a:	f9 06       	cpc	r15, r25
 a0c:	10 f4       	brcc	.+4      	; 0xa12 <xTaskIncrementTick+0x76>
 a0e:	d1 2c       	mov	r13, r1
 a10:	50 c0       	rjmp	.+160    	; 0xab2 <xTaskIncrementTick+0x116>
 a12:	d1 2c       	mov	r13, r1
 a14:	cc 24       	eor	r12, r12
 a16:	c3 94       	inc	r12
 a18:	e0 91 18 07 	lds	r30, 0x0718	; 0x800718 <pxDelayedTaskList>
 a1c:	f0 91 19 07 	lds	r31, 0x0719	; 0x800719 <pxDelayedTaskList+0x1>
 a20:	80 81       	ld	r24, Z
 a22:	81 11       	cpse	r24, r1
 a24:	07 c0       	rjmp	.+14     	; 0xa34 <xTaskIncrementTick+0x98>
 a26:	8f ef       	ldi	r24, 0xFF	; 255
 a28:	9f ef       	ldi	r25, 0xFF	; 255
 a2a:	90 93 03 01 	sts	0x0103, r25	; 0x800103 <xNextTaskUnblockTime+0x1>
 a2e:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <xNextTaskUnblockTime>
 a32:	3f c0       	rjmp	.+126    	; 0xab2 <xTaskIncrementTick+0x116>
 a34:	e0 91 18 07 	lds	r30, 0x0718	; 0x800718 <pxDelayedTaskList>
 a38:	f0 91 19 07 	lds	r31, 0x0719	; 0x800719 <pxDelayedTaskList+0x1>
 a3c:	05 80       	ldd	r0, Z+5	; 0x05
 a3e:	f6 81       	ldd	r31, Z+6	; 0x06
 a40:	e0 2d       	mov	r30, r0
 a42:	c6 81       	ldd	r28, Z+6	; 0x06
 a44:	d7 81       	ldd	r29, Z+7	; 0x07
 a46:	8a 81       	ldd	r24, Y+2	; 0x02
 a48:	9b 81       	ldd	r25, Y+3	; 0x03
 a4a:	e8 16       	cp	r14, r24
 a4c:	f9 06       	cpc	r15, r25
 a4e:	28 f4       	brcc	.+10     	; 0xa5a <xTaskIncrementTick+0xbe>
 a50:	90 93 03 01 	sts	0x0103, r25	; 0x800103 <xNextTaskUnblockTime+0x1>
 a54:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <xNextTaskUnblockTime>
 a58:	2c c0       	rjmp	.+88     	; 0xab2 <xTaskIncrementTick+0x116>
 a5a:	8e 01       	movw	r16, r28
 a5c:	0e 5f       	subi	r16, 0xFE	; 254
 a5e:	1f 4f       	sbci	r17, 0xFF	; 255
 a60:	c8 01       	movw	r24, r16
 a62:	ca db       	rcall	.-2156   	; 0x1f8 <uxListRemove>
 a64:	8c 89       	ldd	r24, Y+20	; 0x14
 a66:	9d 89       	ldd	r25, Y+21	; 0x15
 a68:	89 2b       	or	r24, r25
 a6a:	19 f0       	breq	.+6      	; 0xa72 <xTaskIncrementTick+0xd6>
 a6c:	ce 01       	movw	r24, r28
 a6e:	0c 96       	adiw	r24, 0x0c	; 12
 a70:	c3 db       	rcall	.-2170   	; 0x1f8 <uxListRemove>
 a72:	8e 89       	ldd	r24, Y+22	; 0x16
 a74:	90 91 ff 06 	lds	r25, 0x06FF	; 0x8006ff <uxTopReadyPriority>
 a78:	98 17       	cp	r25, r24
 a7a:	10 f4       	brcc	.+4      	; 0xa80 <xTaskIncrementTick+0xe4>
 a7c:	80 93 ff 06 	sts	0x06FF, r24	; 0x8006ff <uxTopReadyPriority>
 a80:	90 e0       	ldi	r25, 0x00	; 0
 a82:	9c 01       	movw	r18, r24
 a84:	22 0f       	add	r18, r18
 a86:	33 1f       	adc	r19, r19
 a88:	22 0f       	add	r18, r18
 a8a:	33 1f       	adc	r19, r19
 a8c:	22 0f       	add	r18, r18
 a8e:	33 1f       	adc	r19, r19
 a90:	82 0f       	add	r24, r18
 a92:	93 1f       	adc	r25, r19
 a94:	b8 01       	movw	r22, r16
 a96:	84 5d       	subi	r24, 0xD4	; 212
 a98:	98 4f       	sbci	r25, 0xF8	; 248
 a9a:	5c db       	rcall	.-2376   	; 0x154 <vListInsertEnd>
 a9c:	e0 91 50 07 	lds	r30, 0x0750	; 0x800750 <pxCurrentTCB>
 aa0:	f0 91 51 07 	lds	r31, 0x0751	; 0x800751 <pxCurrentTCB+0x1>
 aa4:	9e 89       	ldd	r25, Y+22	; 0x16
 aa6:	86 89       	ldd	r24, Z+22	; 0x16
 aa8:	98 17       	cp	r25, r24
 aaa:	08 f4       	brcc	.+2      	; 0xaae <xTaskIncrementTick+0x112>
 aac:	b5 cf       	rjmp	.-150    	; 0xa18 <xTaskIncrementTick+0x7c>
 aae:	dc 2c       	mov	r13, r12
 ab0:	b3 cf       	rjmp	.-154    	; 0xa18 <xTaskIncrementTick+0x7c>
 ab2:	e0 91 50 07 	lds	r30, 0x0750	; 0x800750 <pxCurrentTCB>
 ab6:	f0 91 51 07 	lds	r31, 0x0751	; 0x800751 <pxCurrentTCB+0x1>
 aba:	86 89       	ldd	r24, Z+22	; 0x16
 abc:	90 e0       	ldi	r25, 0x00	; 0
 abe:	fc 01       	movw	r30, r24
 ac0:	ee 0f       	add	r30, r30
 ac2:	ff 1f       	adc	r31, r31
 ac4:	ee 0f       	add	r30, r30
 ac6:	ff 1f       	adc	r31, r31
 ac8:	ee 0f       	add	r30, r30
 aca:	ff 1f       	adc	r31, r31
 acc:	8e 0f       	add	r24, r30
 ace:	9f 1f       	adc	r25, r31
 ad0:	fc 01       	movw	r30, r24
 ad2:	e4 5d       	subi	r30, 0xD4	; 212
 ad4:	f8 4f       	sbci	r31, 0xF8	; 248
 ad6:	80 81       	ld	r24, Z
 ad8:	82 30       	cpi	r24, 0x02	; 2
 ada:	48 f0       	brcs	.+18     	; 0xaee <xTaskIncrementTick+0x152>
 adc:	dd 24       	eor	r13, r13
 ade:	d3 94       	inc	r13
 ae0:	06 c0       	rjmp	.+12     	; 0xaee <xTaskIncrementTick+0x152>
 ae2:	80 91 fd 06 	lds	r24, 0x06FD	; 0x8006fd <uxPendedTicks>
 ae6:	8f 5f       	subi	r24, 0xFF	; 255
 ae8:	80 93 fd 06 	sts	0x06FD, r24	; 0x8006fd <uxPendedTicks>
 aec:	d1 2c       	mov	r13, r1
 aee:	80 91 fc 06 	lds	r24, 0x06FC	; 0x8006fc <xYieldPending>
 af2:	88 23       	and	r24, r24
 af4:	11 f0       	breq	.+4      	; 0xafa <xTaskIncrementTick+0x15e>
 af6:	dd 24       	eor	r13, r13
 af8:	d3 94       	inc	r13
 afa:	8d 2d       	mov	r24, r13
 afc:	df 91       	pop	r29
 afe:	cf 91       	pop	r28
 b00:	1f 91       	pop	r17
 b02:	0f 91       	pop	r16
 b04:	ff 90       	pop	r15
 b06:	ef 90       	pop	r14
 b08:	df 90       	pop	r13
 b0a:	cf 90       	pop	r12
 b0c:	08 95       	ret

00000b0e <xTaskResumeAll>:
 b0e:	df 92       	push	r13
 b10:	ef 92       	push	r14
 b12:	ff 92       	push	r15
 b14:	0f 93       	push	r16
 b16:	1f 93       	push	r17
 b18:	cf 93       	push	r28
 b1a:	df 93       	push	r29
 b1c:	0f b6       	in	r0, 0x3f	; 63
 b1e:	f8 94       	cli
 b20:	0f 92       	push	r0
 b22:	80 91 f9 06 	lds	r24, 0x06F9	; 0x8006f9 <uxSchedulerSuspended>
 b26:	81 50       	subi	r24, 0x01	; 1
 b28:	80 93 f9 06 	sts	0x06F9, r24	; 0x8006f9 <uxSchedulerSuspended>
 b2c:	80 91 f9 06 	lds	r24, 0x06F9	; 0x8006f9 <uxSchedulerSuspended>
 b30:	81 11       	cpse	r24, r1
 b32:	5d c0       	rjmp	.+186    	; 0xbee <xTaskResumeAll+0xe0>
 b34:	80 91 02 07 	lds	r24, 0x0702	; 0x800702 <uxCurrentNumberOfTasks>
 b38:	81 11       	cpse	r24, r1
 b3a:	30 c0       	rjmp	.+96     	; 0xb9c <xTaskResumeAll+0x8e>
 b3c:	5b c0       	rjmp	.+182    	; 0xbf4 <xTaskResumeAll+0xe6>
 b3e:	d7 01       	movw	r26, r14
 b40:	15 96       	adiw	r26, 0x05	; 5
 b42:	ed 91       	ld	r30, X+
 b44:	fc 91       	ld	r31, X
 b46:	16 97       	sbiw	r26, 0x06	; 6
 b48:	c6 81       	ldd	r28, Z+6	; 0x06
 b4a:	d7 81       	ldd	r29, Z+7	; 0x07
 b4c:	ce 01       	movw	r24, r28
 b4e:	0c 96       	adiw	r24, 0x0c	; 12
 b50:	53 db       	rcall	.-2394   	; 0x1f8 <uxListRemove>
 b52:	8e 01       	movw	r16, r28
 b54:	0e 5f       	subi	r16, 0xFE	; 254
 b56:	1f 4f       	sbci	r17, 0xFF	; 255
 b58:	c8 01       	movw	r24, r16
 b5a:	4e db       	rcall	.-2404   	; 0x1f8 <uxListRemove>
 b5c:	8e 89       	ldd	r24, Y+22	; 0x16
 b5e:	90 91 ff 06 	lds	r25, 0x06FF	; 0x8006ff <uxTopReadyPriority>
 b62:	98 17       	cp	r25, r24
 b64:	10 f4       	brcc	.+4      	; 0xb6a <xTaskResumeAll+0x5c>
 b66:	80 93 ff 06 	sts	0x06FF, r24	; 0x8006ff <uxTopReadyPriority>
 b6a:	90 e0       	ldi	r25, 0x00	; 0
 b6c:	9c 01       	movw	r18, r24
 b6e:	22 0f       	add	r18, r18
 b70:	33 1f       	adc	r19, r19
 b72:	22 0f       	add	r18, r18
 b74:	33 1f       	adc	r19, r19
 b76:	22 0f       	add	r18, r18
 b78:	33 1f       	adc	r19, r19
 b7a:	82 0f       	add	r24, r18
 b7c:	93 1f       	adc	r25, r19
 b7e:	b8 01       	movw	r22, r16
 b80:	84 5d       	subi	r24, 0xD4	; 212
 b82:	98 4f       	sbci	r25, 0xF8	; 248
 b84:	e7 da       	rcall	.-2610   	; 0x154 <vListInsertEnd>
 b86:	e0 91 50 07 	lds	r30, 0x0750	; 0x800750 <pxCurrentTCB>
 b8a:	f0 91 51 07 	lds	r31, 0x0751	; 0x800751 <pxCurrentTCB+0x1>
 b8e:	9e 89       	ldd	r25, Y+22	; 0x16
 b90:	86 89       	ldd	r24, Z+22	; 0x16
 b92:	98 17       	cp	r25, r24
 b94:	58 f0       	brcs	.+22     	; 0xbac <xTaskResumeAll+0x9e>
 b96:	d0 92 fc 06 	sts	0x06FC, r13	; 0x8006fc <xYieldPending>
 b9a:	08 c0       	rjmp	.+16     	; 0xbac <xTaskResumeAll+0x9e>
 b9c:	0f 2e       	mov	r0, r31
 b9e:	fd e0       	ldi	r31, 0x0D	; 13
 ba0:	ef 2e       	mov	r14, r31
 ba2:	f7 e0       	ldi	r31, 0x07	; 7
 ba4:	ff 2e       	mov	r15, r31
 ba6:	f0 2d       	mov	r31, r0
 ba8:	dd 24       	eor	r13, r13
 baa:	d3 94       	inc	r13
 bac:	f7 01       	movw	r30, r14
 bae:	80 81       	ld	r24, Z
 bb0:	81 11       	cpse	r24, r1
 bb2:	c5 cf       	rjmp	.-118    	; 0xb3e <xTaskResumeAll+0x30>
 bb4:	80 91 fd 06 	lds	r24, 0x06FD	; 0x8006fd <uxPendedTicks>
 bb8:	88 23       	and	r24, r24
 bba:	91 f0       	breq	.+36     	; 0xbe0 <xTaskResumeAll+0xd2>
 bbc:	80 91 fd 06 	lds	r24, 0x06FD	; 0x8006fd <uxPendedTicks>
 bc0:	88 23       	and	r24, r24
 bc2:	71 f0       	breq	.+28     	; 0xbe0 <xTaskResumeAll+0xd2>
 bc4:	c1 e0       	ldi	r28, 0x01	; 1
 bc6:	ea de       	rcall	.-556    	; 0x99c <xTaskIncrementTick>
 bc8:	81 11       	cpse	r24, r1
 bca:	c0 93 fc 06 	sts	0x06FC, r28	; 0x8006fc <xYieldPending>
 bce:	80 91 fd 06 	lds	r24, 0x06FD	; 0x8006fd <uxPendedTicks>
 bd2:	81 50       	subi	r24, 0x01	; 1
 bd4:	80 93 fd 06 	sts	0x06FD, r24	; 0x8006fd <uxPendedTicks>
 bd8:	80 91 fd 06 	lds	r24, 0x06FD	; 0x8006fd <uxPendedTicks>
 bdc:	81 11       	cpse	r24, r1
 bde:	f3 cf       	rjmp	.-26     	; 0xbc6 <xTaskResumeAll+0xb8>
 be0:	80 91 fc 06 	lds	r24, 0x06FC	; 0x8006fc <xYieldPending>
 be4:	81 30       	cpi	r24, 0x01	; 1
 be6:	29 f4       	brne	.+10     	; 0xbf2 <xTaskResumeAll+0xe4>
 be8:	d3 db       	rcall	.-2138   	; 0x390 <vPortYield>
 bea:	81 e0       	ldi	r24, 0x01	; 1
 bec:	03 c0       	rjmp	.+6      	; 0xbf4 <xTaskResumeAll+0xe6>
 bee:	80 e0       	ldi	r24, 0x00	; 0
 bf0:	01 c0       	rjmp	.+2      	; 0xbf4 <xTaskResumeAll+0xe6>
 bf2:	80 e0       	ldi	r24, 0x00	; 0
 bf4:	0f 90       	pop	r0
 bf6:	0f be       	out	0x3f, r0	; 63
 bf8:	df 91       	pop	r29
 bfa:	cf 91       	pop	r28
 bfc:	1f 91       	pop	r17
 bfe:	0f 91       	pop	r16
 c00:	ff 90       	pop	r15
 c02:	ef 90       	pop	r14
 c04:	df 90       	pop	r13
 c06:	08 95       	ret

00000c08 <vTaskDelayUntil>:
 c08:	0f 93       	push	r16
 c0a:	1f 93       	push	r17
 c0c:	cf 93       	push	r28
 c0e:	df 93       	push	r29
 c10:	8c 01       	movw	r16, r24
 c12:	eb 01       	movw	r28, r22
 c14:	b3 de       	rcall	.-666    	; 0x97c <vTaskSuspendAll>
 c16:	20 91 00 07 	lds	r18, 0x0700	; 0x800700 <xTickCount>
 c1a:	30 91 01 07 	lds	r19, 0x0701	; 0x800701 <xTickCount+0x1>
 c1e:	f8 01       	movw	r30, r16
 c20:	80 81       	ld	r24, Z
 c22:	91 81       	ldd	r25, Z+1	; 0x01
 c24:	c8 0f       	add	r28, r24
 c26:	d9 1f       	adc	r29, r25
 c28:	28 17       	cp	r18, r24
 c2a:	39 07       	cpc	r19, r25
 c2c:	48 f4       	brcc	.+18     	; 0xc40 <vTaskDelayUntil+0x38>
 c2e:	c8 17       	cp	r28, r24
 c30:	d9 07       	cpc	r29, r25
 c32:	f0 f4       	brcc	.+60     	; 0xc70 <vTaskDelayUntil+0x68>
 c34:	d1 83       	std	Z+1, r29	; 0x01
 c36:	c0 83       	st	Z, r28
 c38:	2c 17       	cp	r18, r28
 c3a:	3d 07       	cpc	r19, r29
 c3c:	80 f4       	brcc	.+32     	; 0xc5e <vTaskDelayUntil+0x56>
 c3e:	07 c0       	rjmp	.+14     	; 0xc4e <vTaskDelayUntil+0x46>
 c40:	c8 17       	cp	r28, r24
 c42:	d9 07       	cpc	r29, r25
 c44:	88 f0       	brcs	.+34     	; 0xc68 <vTaskDelayUntil+0x60>
 c46:	2c 17       	cp	r18, r28
 c48:	3d 07       	cpc	r19, r29
 c4a:	70 f0       	brcs	.+28     	; 0xc68 <vTaskDelayUntil+0x60>
 c4c:	11 c0       	rjmp	.+34     	; 0xc70 <vTaskDelayUntil+0x68>
 c4e:	80 91 50 07 	lds	r24, 0x0750	; 0x800750 <pxCurrentTCB>
 c52:	90 91 51 07 	lds	r25, 0x0751	; 0x800751 <pxCurrentTCB+0x1>
 c56:	02 96       	adiw	r24, 0x02	; 2
 c58:	cf da       	rcall	.-2658   	; 0x1f8 <uxListRemove>
 c5a:	ce 01       	movw	r24, r28
 c5c:	35 dd       	rcall	.-1430   	; 0x6c8 <prvAddCurrentTaskToDelayedList>
 c5e:	57 df       	rcall	.-338    	; 0xb0e <xTaskResumeAll>
 c60:	81 11       	cpse	r24, r1
 c62:	0a c0       	rjmp	.+20     	; 0xc78 <vTaskDelayUntil+0x70>
 c64:	95 db       	rcall	.-2262   	; 0x390 <vPortYield>
 c66:	08 c0       	rjmp	.+16     	; 0xc78 <vTaskDelayUntil+0x70>
 c68:	f8 01       	movw	r30, r16
 c6a:	d1 83       	std	Z+1, r29	; 0x01
 c6c:	c0 83       	st	Z, r28
 c6e:	ef cf       	rjmp	.-34     	; 0xc4e <vTaskDelayUntil+0x46>
 c70:	f8 01       	movw	r30, r16
 c72:	d1 83       	std	Z+1, r29	; 0x01
 c74:	c0 83       	st	Z, r28
 c76:	f3 cf       	rjmp	.-26     	; 0xc5e <vTaskDelayUntil+0x56>
 c78:	df 91       	pop	r29
 c7a:	cf 91       	pop	r28
 c7c:	1f 91       	pop	r17
 c7e:	0f 91       	pop	r16
 c80:	08 95       	ret

00000c82 <prvIdleTask>:
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 c82:	04 e0       	ldi	r16, 0x04	; 4
 c84:	17 e0       	ldi	r17, 0x07	; 7

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 c86:	0f 2e       	mov	r0, r31
 c88:	fc e2       	ldi	r31, 0x2C	; 44
 c8a:	ef 2e       	mov	r14, r31
 c8c:	f7 e0       	ldi	r31, 0x07	; 7
 c8e:	ff 2e       	mov	r15, r31
 c90:	f0 2d       	mov	r31, r0
 c92:	24 c0       	rjmp	.+72     	; 0xcdc <prvIdleTask+0x5a>

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
 c94:	73 de       	rcall	.-794    	; 0x97c <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 c96:	d8 01       	movw	r26, r16
			}
			( void ) xTaskResumeAll();
 c98:	cc 91       	ld	r28, X
 c9a:	39 df       	rcall	.-398    	; 0xb0e <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
 c9c:	cc 23       	and	r28, r28
 c9e:	f1 f0       	breq	.+60     	; 0xcdc <prvIdleTask+0x5a>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
 ca0:	0f b6       	in	r0, 0x3f	; 63
 ca2:	f8 94       	cli
 ca4:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
 ca6:	d8 01       	movw	r26, r16
 ca8:	15 96       	adiw	r26, 0x05	; 5
 caa:	ed 91       	ld	r30, X+
 cac:	fc 91       	ld	r31, X
 cae:	16 97       	sbiw	r26, 0x06	; 6
 cb0:	c6 81       	ldd	r28, Z+6	; 0x06
 cb2:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 cb4:	ce 01       	movw	r24, r28
 cb6:	02 96       	adiw	r24, 0x02	; 2
 cb8:	9f da       	rcall	.-2754   	; 0x1f8 <uxListRemove>
					--uxCurrentNumberOfTasks;
 cba:	80 91 02 07 	lds	r24, 0x0702	; 0x800702 <uxCurrentNumberOfTasks>
 cbe:	81 50       	subi	r24, 0x01	; 1
 cc0:	80 93 02 07 	sts	0x0702, r24	; 0x800702 <uxCurrentNumberOfTasks>
					--uxTasksDeleted;
 cc4:	80 91 03 07 	lds	r24, 0x0703	; 0x800703 <uxTasksDeleted>
 cc8:	81 50       	subi	r24, 0x01	; 1
 cca:	80 93 03 07 	sts	0x0703, r24	; 0x800703 <uxTasksDeleted>
				}
				taskEXIT_CRITICAL();
 cce:	0f 90       	pop	r0
				vPortFreeAligned( pxTCB->pxStack );
			}
		}
		#else
		{
			vPortFreeAligned( pxTCB->pxStack );
 cd0:	0f be       	out	0x3f, r0	; 63
 cd2:	8f 89       	ldd	r24, Y+23	; 0x17
 cd4:	98 8d       	ldd	r25, Y+24	; 0x18
		}
		#endif

		vPortFree( pxTCB );
 cd6:	a8 dc       	rcall	.-1712   	; 0x628 <vPortFree>
 cd8:	ce 01       	movw	r24, r28
 cda:	a6 dc       	rcall	.-1716   	; 0x628 <vPortFree>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
 cdc:	80 91 03 07 	lds	r24, 0x0703	; 0x800703 <uxTasksDeleted>
 ce0:	81 11       	cpse	r24, r1

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 ce2:	d8 cf       	rjmp	.-80     	; 0xc94 <prvIdleTask+0x12>
 ce4:	f7 01       	movw	r30, r14
 ce6:	80 81       	ld	r24, Z
 ce8:	82 30       	cpi	r24, 0x02	; 2
			{
				taskYIELD();
 cea:	c0 f3       	brcs	.-16     	; 0xcdc <prvIdleTask+0x5a>
 cec:	51 db       	rcall	.-2398   	; 0x390 <vPortYield>
 cee:	f6 cf       	rjmp	.-20     	; 0xcdc <prvIdleTask+0x5a>

00000cf0 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 cf0:	80 91 f9 06 	lds	r24, 0x06F9	; 0x8006f9 <uxSchedulerSuspended>
 cf4:	88 23       	and	r24, r24
 cf6:	21 f0       	breq	.+8      	; 0xd00 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
 cf8:	81 e0       	ldi	r24, 0x01	; 1
 cfa:	80 93 fc 06 	sts	0x06FC, r24	; 0x8006fc <xYieldPending>
 cfe:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
 d00:	10 92 fc 06 	sts	0x06FC, r1	; 0x8006fc <xYieldPending>
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
 d04:	80 91 ff 06 	lds	r24, 0x06FF	; 0x8006ff <uxTopReadyPriority>
 d08:	90 e0       	ldi	r25, 0x00	; 0
 d0a:	fc 01       	movw	r30, r24
 d0c:	ee 0f       	add	r30, r30
 d0e:	ff 1f       	adc	r31, r31
 d10:	ee 0f       	add	r30, r30
 d12:	ff 1f       	adc	r31, r31
 d14:	ee 0f       	add	r30, r30
 d16:	ff 1f       	adc	r31, r31
 d18:	8e 0f       	add	r24, r30
 d1a:	9f 1f       	adc	r25, r31
 d1c:	fc 01       	movw	r30, r24
 d1e:	e4 5d       	subi	r30, 0xD4	; 212
 d20:	f8 4f       	sbci	r31, 0xF8	; 248
 d22:	80 81       	ld	r24, Z
 d24:	81 11       	cpse	r24, r1
 d26:	17 c0       	rjmp	.+46     	; 0xd56 <vTaskSwitchContext+0x66>
 d28:	80 91 ff 06 	lds	r24, 0x06FF	; 0x8006ff <uxTopReadyPriority>
 d2c:	81 50       	subi	r24, 0x01	; 1
 d2e:	80 93 ff 06 	sts	0x06FF, r24	; 0x8006ff <uxTopReadyPriority>
 d32:	80 91 ff 06 	lds	r24, 0x06FF	; 0x8006ff <uxTopReadyPriority>
 d36:	90 e0       	ldi	r25, 0x00	; 0
 d38:	fc 01       	movw	r30, r24
 d3a:	ee 0f       	add	r30, r30
 d3c:	ff 1f       	adc	r31, r31
 d3e:	ee 0f       	add	r30, r30
 d40:	ff 1f       	adc	r31, r31
 d42:	ee 0f       	add	r30, r30
 d44:	ff 1f       	adc	r31, r31
 d46:	8e 0f       	add	r24, r30
 d48:	9f 1f       	adc	r25, r31
 d4a:	fc 01       	movw	r30, r24
 d4c:	e4 5d       	subi	r30, 0xD4	; 212
 d4e:	f8 4f       	sbci	r31, 0xF8	; 248
 d50:	80 81       	ld	r24, Z
 d52:	88 23       	and	r24, r24
 d54:	49 f3       	breq	.-46     	; 0xd28 <vTaskSwitchContext+0x38>
 d56:	80 91 ff 06 	lds	r24, 0x06FF	; 0x8006ff <uxTopReadyPriority>
 d5a:	90 e0       	ldi	r25, 0x00	; 0
 d5c:	9c 01       	movw	r18, r24
 d5e:	22 0f       	add	r18, r18
 d60:	33 1f       	adc	r19, r19
 d62:	22 0f       	add	r18, r18
 d64:	33 1f       	adc	r19, r19
 d66:	22 0f       	add	r18, r18
 d68:	33 1f       	adc	r19, r19
 d6a:	28 0f       	add	r18, r24
 d6c:	39 1f       	adc	r19, r25
 d6e:	d9 01       	movw	r26, r18
 d70:	a4 5d       	subi	r26, 0xD4	; 212
 d72:	b8 4f       	sbci	r27, 0xF8	; 248
 d74:	11 96       	adiw	r26, 0x01	; 1
 d76:	ed 91       	ld	r30, X+
 d78:	fc 91       	ld	r31, X
 d7a:	12 97       	sbiw	r26, 0x02	; 2
 d7c:	02 80       	ldd	r0, Z+2	; 0x02
 d7e:	f3 81       	ldd	r31, Z+3	; 0x03
 d80:	e0 2d       	mov	r30, r0
 d82:	12 96       	adiw	r26, 0x02	; 2
 d84:	fc 93       	st	X, r31
 d86:	ee 93       	st	-X, r30
 d88:	11 97       	sbiw	r26, 0x01	; 1
 d8a:	21 5d       	subi	r18, 0xD1	; 209
 d8c:	38 4f       	sbci	r19, 0xF8	; 248
 d8e:	e2 17       	cp	r30, r18
 d90:	f3 07       	cpc	r31, r19
 d92:	29 f4       	brne	.+10     	; 0xd9e <vTaskSwitchContext+0xae>
 d94:	22 81       	ldd	r18, Z+2	; 0x02
 d96:	33 81       	ldd	r19, Z+3	; 0x03
 d98:	fd 01       	movw	r30, r26
 d9a:	32 83       	std	Z+2, r19	; 0x02
 d9c:	21 83       	std	Z+1, r18	; 0x01
 d9e:	fc 01       	movw	r30, r24
 da0:	ee 0f       	add	r30, r30
 da2:	ff 1f       	adc	r31, r31
 da4:	ee 0f       	add	r30, r30
 da6:	ff 1f       	adc	r31, r31
 da8:	ee 0f       	add	r30, r30
 daa:	ff 1f       	adc	r31, r31
 dac:	8e 0f       	add	r24, r30
 dae:	9f 1f       	adc	r25, r31
 db0:	fc 01       	movw	r30, r24
 db2:	e4 5d       	subi	r30, 0xD4	; 212
 db4:	f8 4f       	sbci	r31, 0xF8	; 248
 db6:	01 80       	ldd	r0, Z+1	; 0x01
 db8:	f2 81       	ldd	r31, Z+2	; 0x02
 dba:	e0 2d       	mov	r30, r0
 dbc:	86 81       	ldd	r24, Z+6	; 0x06
 dbe:	97 81       	ldd	r25, Z+7	; 0x07
 dc0:	90 93 51 07 	sts	0x0751, r25	; 0x800751 <pxCurrentTCB+0x1>
 dc4:	80 93 50 07 	sts	0x0750, r24	; 0x800750 <pxCurrentTCB>
 dc8:	08 95       	ret

00000dca <_exit>:
 dca:	f8 94       	cli

00000dcc <__stop_program>:
 dcc:	ff cf       	rjmp	.-2      	; 0xdcc <__stop_program>
